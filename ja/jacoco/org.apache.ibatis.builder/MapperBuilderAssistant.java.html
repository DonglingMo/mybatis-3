<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapperBuilderAssistant.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.builder</a> &gt; <span class="el_source">MapperBuilderAssistant.java</span></div><h1>MapperBuilderAssistant.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2009-2024 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.builder;

import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;

import org.apache.ibatis.cache.Cache;
import org.apache.ibatis.cache.decorators.LruCache;
import org.apache.ibatis.cache.impl.PerpetualCache;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.mapping.CacheBuilder;
import org.apache.ibatis.mapping.Discriminator;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMap;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.mapping.ParameterMode;
import org.apache.ibatis.mapping.ResultFlag;
import org.apache.ibatis.mapping.ResultMap;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.mapping.ResultSetType;
import org.apache.ibatis.mapping.SqlCommandType;
import org.apache.ibatis.mapping.SqlSource;
import org.apache.ibatis.mapping.StatementType;
import org.apache.ibatis.reflection.MetaClass;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;

/**
 * @author Clinton Begin
 */
public class MapperBuilderAssistant extends BaseBuilder {

  private String currentNamespace;
  private final String resource;
  private Cache currentCache;
  private boolean unresolvedCacheRef; // issue #676

  public MapperBuilderAssistant(Configuration configuration, String resource) {
<span class="fc" id="L64">    super(configuration);</span>
<span class="fc" id="L65">    ErrorContext.instance().resource(resource);</span>
<span class="fc" id="L66">    this.resource = resource;</span>
<span class="fc" id="L67">  }</span>

  public String getCurrentNamespace() {
<span class="fc" id="L70">    return currentNamespace;</span>
  }

  public void setCurrentNamespace(String currentNamespace) {
<span class="fc bfc" id="L74" title="All 2 branches covered.">    if (currentNamespace == null) {</span>
<span class="fc" id="L75">      throw new BuilderException(&quot;The mapper element requires a namespace attribute to be specified.&quot;);</span>
    }

<span class="fc bfc" id="L78" title="All 4 branches covered.">    if (this.currentNamespace != null &amp;&amp; !this.currentNamespace.equals(currentNamespace)) {</span>
<span class="fc" id="L79">      throw new BuilderException(</span>
          &quot;Wrong namespace. Expected '&quot; + this.currentNamespace + &quot;' but found '&quot; + currentNamespace + &quot;'.&quot;);
    }

<span class="fc" id="L83">    this.currentNamespace = currentNamespace;</span>
<span class="fc" id="L84">  }</span>

  public String applyCurrentNamespace(String base, boolean isReference) {
<span class="fc bfc" id="L87" title="All 2 branches covered.">    if (base == null) {</span>
<span class="fc" id="L88">      return null;</span>
    }
<span class="fc bfc" id="L90" title="All 2 branches covered.">    if (isReference) {</span>
      // is it qualified with any namespace yet?
<span class="fc bfc" id="L92" title="All 2 branches covered.">      if (base.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L93">        return base;</span>
      }
    } else {
      // is it qualified with this namespace yet?
<span class="fc bfc" id="L97" title="All 2 branches covered.">      if (base.startsWith(currentNamespace + &quot;.&quot;)) {</span>
<span class="fc" id="L98">        return base;</span>
      }
<span class="fc bfc" id="L100" title="All 2 branches covered.">      if (base.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L101">        throw new BuilderException(&quot;Dots are not allowed in element names, please remove it from &quot; + base);</span>
      }
    }
<span class="fc" id="L104">    return currentNamespace + &quot;.&quot; + base;</span>
  }

  public Cache useCacheRef(String namespace) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">    if (namespace == null) {</span>
<span class="fc" id="L109">      throw new BuilderException(&quot;cache-ref element requires a namespace attribute.&quot;);</span>
    }
    try {
<span class="fc" id="L112">      unresolvedCacheRef = true;</span>
<span class="fc" id="L113">      Cache cache = configuration.getCache(namespace);</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">      if (cache == null) {</span>
<span class="nc" id="L115">        throw new IncompleteElementException(&quot;No cache for namespace '&quot; + namespace + &quot;' could be found.&quot;);</span>
      }
<span class="fc" id="L117">      currentCache = cache;</span>
<span class="fc" id="L118">      unresolvedCacheRef = false;</span>
<span class="fc" id="L119">      return cache;</span>
<span class="fc" id="L120">    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L121">      throw new IncompleteElementException(&quot;No cache for namespace '&quot; + namespace + &quot;' could be found.&quot;, e);</span>
    }
  }

  public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass, Class&lt;? extends Cache&gt; evictionClass, Long flushInterval,
      Integer size, boolean readWrite, boolean blocking, Properties props) {
<span class="fc" id="L127">    Cache cache = new CacheBuilder(currentNamespace).implementation(valueOrDefault(typeClass, PerpetualCache.class))</span>
<span class="fc" id="L128">        .addDecorator(valueOrDefault(evictionClass, LruCache.class)).clearInterval(flushInterval).size(size)</span>
<span class="fc" id="L129">        .readWrite(readWrite).blocking(blocking).properties(props).build();</span>
<span class="fc" id="L130">    configuration.addCache(cache);</span>
<span class="fc" id="L131">    currentCache = cache;</span>
<span class="fc" id="L132">    return cache;</span>
  }

  public ParameterMap addParameterMap(String id, Class&lt;?&gt; parameterClass, List&lt;ParameterMapping&gt; parameterMappings) {
<span class="fc" id="L136">    id = applyCurrentNamespace(id, false);</span>
<span class="fc" id="L137">    ParameterMap parameterMap = new ParameterMap.Builder(configuration, id, parameterClass, parameterMappings).build();</span>
<span class="fc" id="L138">    configuration.addParameterMap(parameterMap);</span>
<span class="fc" id="L139">    return parameterMap;</span>
  }

  public ParameterMapping buildParameterMapping(Class&lt;?&gt; parameterType, String property, Class&lt;?&gt; javaType,
      JdbcType jdbcType, String resultMap, ParameterMode parameterMode, Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,
      Integer numericScale) {
<span class="fc" id="L145">    resultMap = applyCurrentNamespace(resultMap, true);</span>

    // Class parameterType = parameterMapBuilder.type();
<span class="fc" id="L148">    Class&lt;?&gt; javaTypeClass = resolveParameterJavaType(parameterType, property, javaType, jdbcType);</span>
<span class="fc" id="L149">    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);</span>

<span class="fc" id="L151">    return new ParameterMapping.Builder(configuration, property, javaTypeClass).jdbcType(jdbcType)</span>
<span class="fc" id="L152">        .resultMapId(resultMap).mode(parameterMode).numericScale(numericScale).typeHandler(typeHandlerInstance).build();</span>
  }

  public ResultMap addResultMap(String id, Class&lt;?&gt; type, String extend, Discriminator discriminator,
      List&lt;ResultMapping&gt; resultMappings, Boolean autoMapping) {
<span class="fc" id="L157">    id = applyCurrentNamespace(id, false);</span>
<span class="fc" id="L158">    extend = applyCurrentNamespace(extend, true);</span>

<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (extend != null) {</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">      if (!configuration.hasResultMap(extend)) {</span>
<span class="fc" id="L162">        throw new IncompleteElementException(&quot;Could not find a parent resultmap with id '&quot; + extend + &quot;'&quot;);</span>
      }
<span class="fc" id="L164">      ResultMap resultMap = configuration.getResultMap(extend);</span>
<span class="fc" id="L165">      List&lt;ResultMapping&gt; extendedResultMappings = new ArrayList&lt;&gt;(resultMap.getResultMappings());</span>
<span class="fc" id="L166">      extendedResultMappings.removeAll(resultMappings);</span>
      // Remove parent constructor if this resultMap declares a constructor.
<span class="fc" id="L168">      boolean declaresConstructor = false;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      for (ResultMapping resultMapping : resultMappings) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {</span>
<span class="fc" id="L171">          declaresConstructor = true;</span>
<span class="fc" id="L172">          break;</span>
        }
<span class="fc" id="L174">      }</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (declaresConstructor) {</span>
<span class="fc" id="L176">        extendedResultMappings.removeIf(resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));</span>
      }
<span class="fc" id="L178">      resultMappings.addAll(extendedResultMappings);</span>
    }
<span class="fc" id="L180">    ResultMap resultMap = new ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span>
<span class="fc" id="L181">        .discriminator(discriminator).build();</span>
<span class="fc" id="L182">    configuration.addResultMap(resultMap);</span>
<span class="fc" id="L183">    return resultMap;</span>
  }

  public Discriminator buildDiscriminator(Class&lt;?&gt; resultType, String column, Class&lt;?&gt; javaType, JdbcType jdbcType,
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler, Map&lt;String, String&gt; discriminatorMap) {
<span class="fc" id="L188">    ResultMapping resultMapping = buildResultMapping(resultType, null, column, javaType, jdbcType, null, null, null,</span>
        null, typeHandler, new ArrayList&lt;&gt;(), null, null, false);
<span class="fc" id="L190">    Map&lt;String, String&gt; namespaceDiscriminatorMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">    for (Map.Entry&lt;String, String&gt; e : discriminatorMap.entrySet()) {</span>
<span class="fc" id="L192">      String resultMap = e.getValue();</span>
<span class="fc" id="L193">      resultMap = applyCurrentNamespace(resultMap, true);</span>
<span class="fc" id="L194">      namespaceDiscriminatorMap.put(e.getKey(), resultMap);</span>
<span class="fc" id="L195">    }</span>
<span class="fc" id="L196">    return new Discriminator.Builder(configuration, resultMapping, namespaceDiscriminatorMap).build();</span>
  }

  public MappedStatement addMappedStatement(String id, SqlSource sqlSource, StatementType statementType,
      SqlCommandType sqlCommandType, Integer fetchSize, Integer timeout, String parameterMap, Class&lt;?&gt; parameterType,
      String resultMap, Class&lt;?&gt; resultType, ResultSetType resultSetType, boolean flushCache, boolean useCache,
      boolean resultOrdered, KeyGenerator keyGenerator, String keyProperty, String keyColumn, String databaseId,
      LanguageDriver lang, String resultSets, boolean dirtySelect) {

<span class="fc bfc" id="L205" title="All 2 branches covered.">    if (unresolvedCacheRef) {</span>
<span class="fc" id="L206">      throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;);</span>
    }

<span class="fc" id="L209">    id = applyCurrentNamespace(id, false);</span>

<span class="fc" id="L211">    MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span>
<span class="fc" id="L212">        .resource(resource).fetchSize(fetchSize).timeout(timeout).statementType(statementType)</span>
<span class="fc" id="L213">        .keyGenerator(keyGenerator).keyProperty(keyProperty).keyColumn(keyColumn).databaseId(databaseId).lang(lang)</span>
<span class="fc" id="L214">        .resultOrdered(resultOrdered).resultSets(resultSets)</span>
<span class="fc" id="L215">        .resultMaps(getStatementResultMaps(resultMap, resultType, id)).resultSetType(resultSetType)</span>
<span class="fc" id="L216">        .flushCacheRequired(flushCache).useCache(useCache).cache(currentCache).dirtySelect(dirtySelect);</span>

<span class="fc" id="L218">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">    if (statementParameterMap != null) {</span>
<span class="fc" id="L220">      statementBuilder.parameterMap(statementParameterMap);</span>
    }

<span class="fc" id="L223">    MappedStatement statement = statementBuilder.build();</span>
<span class="fc" id="L224">    configuration.addMappedStatement(statement);</span>
<span class="fc" id="L225">    return statement;</span>
  }

  /**
   * Backward compatibility signature 'addMappedStatement'.
   *
   * @param id
   *          the id
   * @param sqlSource
   *          the sql source
   * @param statementType
   *          the statement type
   * @param sqlCommandType
   *          the sql command type
   * @param fetchSize
   *          the fetch size
   * @param timeout
   *          the timeout
   * @param parameterMap
   *          the parameter map
   * @param parameterType
   *          the parameter type
   * @param resultMap
   *          the result map
   * @param resultType
   *          the result type
   * @param resultSetType
   *          the result set type
   * @param flushCache
   *          the flush cache
   * @param useCache
   *          the use cache
   * @param resultOrdered
   *          the result ordered
   * @param keyGenerator
   *          the key generator
   * @param keyProperty
   *          the key property
   * @param keyColumn
   *          the key column
   * @param databaseId
   *          the database id
   * @param lang
   *          the lang
   *
   * @return the mapped statement
   */
  public MappedStatement addMappedStatement(String id, SqlSource sqlSource, StatementType statementType,
      SqlCommandType sqlCommandType, Integer fetchSize, Integer timeout, String parameterMap, Class&lt;?&gt; parameterType,
      String resultMap, Class&lt;?&gt; resultType, ResultSetType resultSetType, boolean flushCache, boolean useCache,
      boolean resultOrdered, KeyGenerator keyGenerator, String keyProperty, String keyColumn, String databaseId,
      LanguageDriver lang, String resultSets) {
<span class="nc" id="L277">    return addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap,</span>
        parameterType, resultMap, resultType, resultSetType, flushCache, useCache, resultOrdered, keyGenerator,
        keyProperty, keyColumn, databaseId, lang, null, false);
  }

  public MappedStatement addMappedStatement(String id, SqlSource sqlSource, StatementType statementType,
      SqlCommandType sqlCommandType, Integer fetchSize, Integer timeout, String parameterMap, Class&lt;?&gt; parameterType,
      String resultMap, Class&lt;?&gt; resultType, ResultSetType resultSetType, boolean flushCache, boolean useCache,
      boolean resultOrdered, KeyGenerator keyGenerator, String keyProperty, String keyColumn, String databaseId,
      LanguageDriver lang) {
<span class="nc" id="L287">    return addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap,</span>
        parameterType, resultMap, resultType, resultSetType, flushCache, useCache, resultOrdered, keyGenerator,
        keyProperty, keyColumn, databaseId, lang, null);
  }

  private &lt;T&gt; T valueOrDefault(T value, T defaultValue) {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">    return value == null ? defaultValue : value;</span>
  }

  private ParameterMap getStatementParameterMap(String parameterMapName, Class&lt;?&gt; parameterTypeClass,
      String statementId) {
<span class="fc" id="L298">    parameterMapName = applyCurrentNamespace(parameterMapName, true);</span>
<span class="fc" id="L299">    ParameterMap parameterMap = null;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">    if (parameterMapName != null) {</span>
      try {
<span class="fc" id="L302">        parameterMap = configuration.getParameterMap(parameterMapName);</span>
<span class="fc" id="L303">      } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L304">        throw new IncompleteElementException(&quot;Could not find parameter map &quot; + parameterMapName, e);</span>
<span class="fc" id="L305">      }</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">    } else if (parameterTypeClass != null) {</span>
<span class="fc" id="L307">      List&lt;ParameterMapping&gt; parameterMappings = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L308">      parameterMap = new ParameterMap.Builder(configuration, statementId + &quot;-Inline&quot;, parameterTypeClass,</span>
<span class="fc" id="L309">          parameterMappings).build();</span>
    }
<span class="fc" id="L311">    return parameterMap;</span>
  }

  private List&lt;ResultMap&gt; getStatementResultMaps(String resultMap, Class&lt;?&gt; resultType, String statementId) {
<span class="fc" id="L315">    resultMap = applyCurrentNamespace(resultMap, true);</span>

<span class="fc" id="L317">    List&lt;ResultMap&gt; resultMaps = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">    if (resultMap != null) {</span>
<span class="fc" id="L319">      String[] resultMapNames = resultMap.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">      for (String resultMapName : resultMapNames) {</span>
        try {
<span class="fc" id="L322">          resultMaps.add(configuration.getResultMap(resultMapName.trim()));</span>
<span class="fc" id="L323">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L324">          throw new IncompleteElementException(</span>
              &quot;Could not find result map '&quot; + resultMapName + &quot;' referenced from '&quot; + statementId + &quot;'&quot;, e);
<span class="fc" id="L326">        }</span>
      }
<span class="fc bfc" id="L328" title="All 2 branches covered.">    } else if (resultType != null) {</span>
<span class="fc" id="L329">      ResultMap inlineResultMap = new ResultMap.Builder(configuration, statementId + &quot;-Inline&quot;, resultType,</span>
<span class="fc" id="L330">          new ArrayList&lt;&gt;(), null).build();</span>
<span class="fc" id="L331">      resultMaps.add(inlineResultMap);</span>
    }
<span class="fc" id="L333">    return resultMaps;</span>
  }

  public ResultMapping buildResultMapping(Class&lt;?&gt; resultType, String property, String column, Class&lt;?&gt; javaType,
      JdbcType jdbcType, String nestedSelect, String nestedResultMap, String notNullColumn, String columnPrefix,
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler, List&lt;ResultFlag&gt; flags, String resultSet, String foreignColumn,
      boolean lazy) {
<span class="fc" id="L340">    Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType);</span>
<span class="fc" id="L341">    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);</span>
    List&lt;ResultMapping&gt; composites;
<span class="pc bpc" id="L343" title="2 of 8 branches missed.">    if ((nestedSelect == null || nestedSelect.isEmpty()) &amp;&amp; (foreignColumn == null || foreignColumn.isEmpty())) {</span>
<span class="fc" id="L344">      composites = Collections.emptyList();</span>
    } else {
<span class="fc" id="L346">      composites = parseCompositeColumnName(column);</span>
    }
<span class="fc" id="L348">    return new ResultMapping.Builder(configuration, property, column, javaTypeClass).jdbcType(jdbcType)</span>
<span class="fc" id="L349">        .nestedQueryId(applyCurrentNamespace(nestedSelect, true))</span>
<span class="fc" id="L350">        .nestedResultMapId(applyCurrentNamespace(nestedResultMap, true)).resultSet(resultSet)</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        .typeHandler(typeHandlerInstance).flags(flags == null ? new ArrayList&lt;&gt;() : flags).composites(composites)</span>
<span class="fc" id="L352">        .notNullColumns(parseMultipleColumnNames(notNullColumn)).columnPrefix(columnPrefix).foreignColumn(foreignColumn)</span>
<span class="fc" id="L353">        .lazy(lazy).build();</span>
  }

  /**
   * Backward compatibility signature 'buildResultMapping'.
   *
   * @param resultType
   *          the result type
   * @param property
   *          the property
   * @param column
   *          the column
   * @param javaType
   *          the java type
   * @param jdbcType
   *          the jdbc type
   * @param nestedSelect
   *          the nested select
   * @param nestedResultMap
   *          the nested result map
   * @param notNullColumn
   *          the not null column
   * @param columnPrefix
   *          the column prefix
   * @param typeHandler
   *          the type handler
   * @param flags
   *          the flags
   *
   * @return the result mapping
   */
  public ResultMapping buildResultMapping(Class&lt;?&gt; resultType, String property, String column, Class&lt;?&gt; javaType,
      JdbcType jdbcType, String nestedSelect, String nestedResultMap, String notNullColumn, String columnPrefix,
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler, List&lt;ResultFlag&gt; flags) {
<span class="nc" id="L387">    return buildResultMapping(resultType, property, column, javaType, jdbcType, nestedSelect, nestedResultMap,</span>
<span class="nc" id="L388">        notNullColumn, columnPrefix, typeHandler, flags, null, null, configuration.isLazyLoadingEnabled());</span>
  }

  /**
   * Gets the language driver.
   *
   * @param langClass
   *          the lang class
   *
   * @return the language driver
   *
   * @deprecated Use {@link Configuration#getLanguageDriver(Class)}
   */
  @Deprecated
  public LanguageDriver getLanguageDriver(Class&lt;? extends LanguageDriver&gt; langClass) {
<span class="nc" id="L403">    return configuration.getLanguageDriver(langClass);</span>
  }

  private Set&lt;String&gt; parseMultipleColumnNames(String columnName) {
<span class="fc" id="L407">    Set&lt;String&gt; columns = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">    if (columnName != null) {</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">      if (columnName.indexOf(',') &gt; -1) {</span>
<span class="fc" id="L410">        StringTokenizer parser = new StringTokenizer(columnName, &quot;{}, &quot;, false);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L412">          String column = parser.nextToken();</span>
<span class="fc" id="L413">          columns.add(column);</span>
<span class="fc" id="L414">        }</span>
<span class="fc" id="L415">      } else {</span>
<span class="fc" id="L416">        columns.add(columnName);</span>
      }
    }
<span class="fc" id="L419">    return columns;</span>
  }

  private List&lt;ResultMapping&gt; parseCompositeColumnName(String columnName) {
<span class="fc" id="L423">    List&lt;ResultMapping&gt; composites = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L424" title="1 of 6 branches missed.">    if (columnName != null &amp;&amp; (columnName.indexOf('=') &gt; -1 || columnName.indexOf(',') &gt; -1)) {</span>
<span class="fc" id="L425">      StringTokenizer parser = new StringTokenizer(columnName, &quot;{}=, &quot;, false);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L427">        String property = parser.nextToken();</span>
<span class="fc" id="L428">        String column = parser.nextToken();</span>
<span class="fc" id="L429">        ResultMapping complexResultMapping = new ResultMapping.Builder(configuration, property, column,</span>
<span class="fc" id="L430">            configuration.getTypeHandlerRegistry().getUnknownTypeHandler()).build();</span>
<span class="fc" id="L431">        composites.add(complexResultMapping);</span>
<span class="fc" id="L432">      }</span>
    }
<span class="fc" id="L434">    return composites;</span>
  }

  private Class&lt;?&gt; resolveResultJavaType(Class&lt;?&gt; resultType, String property, Class&lt;?&gt; javaType) {
<span class="fc bfc" id="L438" title="All 4 branches covered.">    if (javaType == null &amp;&amp; property != null) {</span>
      try {
<span class="fc" id="L440">        MetaClass metaResultType = MetaClass.forClass(resultType, configuration.getReflectorFactory());</span>
<span class="fc" id="L441">        javaType = metaResultType.getSetterType(property);</span>
<span class="fc" id="L442">      } catch (Exception e) {</span>
        // ignore, following null check statement will deal with the situation
<span class="fc" id="L444">      }</span>
    }
<span class="fc bfc" id="L446" title="All 2 branches covered.">    if (javaType == null) {</span>
<span class="fc" id="L447">      javaType = Object.class;</span>
    }
<span class="fc" id="L449">    return javaType;</span>
  }

  private Class&lt;?&gt; resolveParameterJavaType(Class&lt;?&gt; resultType, String property, Class&lt;?&gt; javaType,
      JdbcType jdbcType) {
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">    if (javaType == null) {</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">      if (JdbcType.CURSOR.equals(jdbcType)) {</span>
<span class="nc" id="L456">        javaType = ResultSet.class;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">      } else if (Map.class.isAssignableFrom(resultType)) {</span>
<span class="fc" id="L458">        javaType = Object.class;</span>
      } else {
<span class="fc" id="L460">        MetaClass metaResultType = MetaClass.forClass(resultType, configuration.getReflectorFactory());</span>
<span class="fc" id="L461">        javaType = metaResultType.getGetterType(property);</span>
      }
    }
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">    if (javaType == null) {</span>
<span class="nc" id="L465">      javaType = Object.class;</span>
    }
<span class="fc" id="L467">    return javaType;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>