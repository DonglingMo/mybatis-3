<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0-M19 from src/site/es/xdoc/java-api.xml at 27 noviembre 2024
 | Rendered using Apache Maven Fluido Skin 2.0.0-M9
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0-M19" />
    <meta name="author" content="Clinton Begin" />
    <meta name="author" content="Eduardo Macarron" />
    <title>MyBatis 3 | Java API – mybatis</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M9.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M9.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"><div id="bannerRight"><h1><a href="https://blog.mybatis.org/" class="externalLink"><img class="imageLink" src="../../images/mybatis-logo.png" alt="MyBatis logo" /> MyBatis</a></h1></div></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Publicado el: 26 noviembre 2024<span class="divider">|</span>
</li>
          <li id="projectVersion">Versión: 3.5.17</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Manual de Referencia</li>
    <li><a href="index.html">Introducción</a></li>
    <li><a href="getting-started.html">Primeros pasos</a></li>
    <li><a href="configuration.html"><span class="icon-chevron-right"></span>Configuración</a></li>
    <li><a href="sqlmap-xml.html"><span class="icon-chevron-right"></span>Ficheros XML de mapeo</a></li>
    <li><a href="dynamic-sql.html">SQL dinámico</a></li>
    <li class="active"><a><span class="icon-chevron-down"></span>Java API</a>
     <ul class="nav nav-list">
      <li><a href="java-api.html#directoryStructure">Directory Structure</a></li>
      <li><a href="java-api.html#sqlSessions">SqlSessions</a></li>
     </ul></li>
    <li><a href="statement-builders.html">La clase SQL</a></li>
    <li><a href="logging.html">Logging</a></li>
   <li class="nav-header">Documentación del proyecto</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Información del proyecto</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-right"></span>Informes del proyecto</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Generado por Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">


  
  <a id="javaApi"></a><section id="javaApi"><a id="Java_API"></a>
<h1>Java API</h1>
  
<p>Ahora que ya conoces c&#xf3;mo configurar MyBatis y crear mapeos est&#xe1;s listo para lo mejor. El API Java es donde obtendr&#xe1;s los mejores frutos de tus esfuerzos. Como ver&#xe1;s, comparado con JDBC, MyBatis simplifica enormemente tu c&#xf3;digo y lo mantiene limpio, de f&#xe1;cil comprensi&#xf3;n y mantenimiento. MyBatis 3 incorpora muchas mejoras significativas para hacer que el trabajo con SQL Maps sea aun mejor.</p>

  <a id="directoryStructure"></a><section id="directoryStructure"><a id="Directory_Structure"></a>
<h2>Directory Structure</h2>
  
<p>Antes de zambullirnos en el propio API Java , es importante comprender las mejores pr&#xe1;cticas relativas a la estructura de directorios. MyBatis es muy flexible, y puedes hacer casi cualquier cosa con tus ficheros. Pero como en cualquier otro framework, hay una forma recomendable.</p>
  
<p>Veamos una estructura de directorios t&#xed;pica:</p>
  
<pre>/my_application
  /bin
  /devlib
  <strong>/lib                <code>&lt;-- Los ficheros .jar de MyBatis van aqui.</code></strong>
  /src
    /org/myapp/
      /action
      <strong>/data           <code>&lt;-- Los artefactos de MyBatis van aqui, lo que incluye, mappers, configuraci&#xf3;n XML, y ficheros de mapeo XML.</code></strong>
        /mybatis-config.xml
        /BlogMapper.java
        /BlogMapper.xml
      /model
      /service
      /view
    <strong>/properties       <code>&lt;-- Las Properties incluidas en tu configuraci&#xf3;n XML van aqui.</code></strong>
  /test
    /org/myapp/
      /action
      /data
      /model
      /service
      /view
    /properties
  /web
    /WEB-INF
      /web.xml</pre>
  
<p>Recuerda, esto son prefierncias no requisitos, pero habr&#xe1; otros que te agradecer&#xe1;n que uses una estructura de directorios con&#xfa;n.</p>
  
<p>Los ejemplos restantes en esta secci&#xf3;n asumen que est&#xe1;s utilizando esta estructura de directorios.</p>
  </section>

  <a id="sqlSessions"></a><section id="sqlSessions"><a id="SqlSessions"></a>
<h2>SqlSessions</h2>
  
<p>El interfaz principal para trabajar con MyBatis es el SqlSession. A trav&#xe9;s de este interfaz puedes ejecutar comandos, obtener mappers y gestionar transacciones. Hablaremos m&#xe1;s sobre el propio SqlSession en breve, pero primero veamos c&#xf3;mo obtener una instancia de SqlSession. Las SqlSessions se crean por una instancia de SqlSessionFactory. La SqlSessionFactory contiene m&#xe9;todos para crear instancias de SqlSessions de distintas formas. La SqlSessionFactory en si misma se crea por la SqlSessionFactoryBuilder que puede crear una SqlSessionFactory a partir de XML, anotaciones o un objeto Configuration creado por c&#xf3;digo.</p>
  
<p><span class="label important">NOTE</span> When using MyBatis with a dependency injection framework like Spring or Guice, SqlSessions are created and injected by the DI framework so you don't need to use the SqlSessionFactoryBuilder or SqlSessionFactory and can go directly to the SqlSession section. Please refer to the MyBatis-Spring or MyBatis-Guice manuals for further info.</p>
  <section><a id="SqlSessionFactoryBuilder"></a><section><a id="SqlSessionFactoryBuilder"></a>
<h4>SqlSessionFactoryBuilder</h4>
  
<p>El SqlSessionFactoryBuilder tiene cinco m&#xe9;todos build(), cada cual permite construir una SqlSessionFactory desde un origen distinto.</p>
  
<pre class="prettyprint"><code>SqlSessionFactory build(InputStream inputStream)
SqlSessionFactory build(InputStream inputStream, String environment)
SqlSessionFactory build(InputStream inputStream, Properties properties)
SqlSessionFactory build(InputStream inputStream, String env, Properties props)
SqlSessionFactory build(Configuration config)</code></pre>

  
<p>Los primeros cuatro m&#xe9;todos son los m&#xe1;s comunes, dado que reciben una instancia de InputStream que referencia a un documento XML, o m&#xe1;s espec&#xed;ficamente, al fichero SqlMapConfig.xml comentado anteriormente. Los par&#xe1;metros opcionales son environment y properties. Environment determina qu&#xe9; entorno cargar, incluyendo el datasource y el gestor de transacciones. Por ejemplo:</p>

  
<pre class="prettyprint"><code>&lt;environments default=&quot;development&quot;&gt;
  &lt;environment id=&quot;development&quot;&gt;
    &lt;transactionManager type=&quot;JDBC&quot;&gt;
        ...
    &lt;dataSource type=&quot;POOLED&quot;&gt;
        ...
  &lt;/environment&gt;
  &lt;environment id=&quot;production&quot;&gt;
    &lt;transactionManager type=&quot;MANAGED&quot;&gt;
        ...
    &lt;dataSource type=&quot;JNDI&quot;&gt;
        ...
  &lt;/environment&gt;
&lt;/environments&gt;</code></pre>
  
<p>Si llamas al m&#xe9;todo build que recibe el par&#xe1;metro environment, entonces MyBatis usar&#xe1; la configuraci&#xf3;n de dicho entorno. Por supuesto, si especificas un entorno inv&#xe1;lido, recibir&#xe1;s un error. Si llamas a alguno de los m&#xe9;todos que no reciben el par&#xe1;metro environment, entonces se utilizar&#xe1; el entorno por defecto (que es el especificado como default=&#x201d;development&#x201d; en el ejemplo anterior).</p>
  
<p>Si llamas a un m&#xe9;todo que recibe una instancia de properties, MyBatis cargar&#xe1; dichas properties y las har&#xe1; accesibles desde tu configuraci&#xf3;n. Estas propiedades pueden usarse en lugar de la gran mayor&#xed;a de los valores utilizando al sintaxis: ${propName}</p>
  
<p>Recuerda que las propiedades pueden tambi&#xe9;n referenciarse desde el fichero SqlMapConfig.xml, o especificarse directamente en &#xe9;l. Por lo tanto es importante conocer las prioridades. Lo mencionamos anteriormente en este documento, pero lo volvemos a mencionar para facilitar la referencia.</p>

  <hr />
  
<p>Si una propiedad existe en m&#xe1;s de un lugar, MyBatis la carga en el siguiente orden:</p>
  
<ul>
  
<li>Las propiedades especificadas en el cuerpo del elemento properties se cargan al principio.</li>
  
<li>Las propiedades cargadas desde los atributos resource/url del elemento properties se leen a continuaci&#xf3;n, y sobrescriben cualquier propiedad duplicada que hubiera sido cargada anteriormente.</li>
  
<li>Las propiedades pasadas como argumento se leen al final, y sobrescriben cualquier propiedad duplicada que hubiera sido cargada anteriormente.</li>
  </ul>
  
<p>Por lo tanto la prioridad mayor es la de las propiedades pasadas como par&#xe1;metro, seguidas por las especificadas en el atributo resource/url y finalmente las propiedades especificadas en el cuerpo del elemento properties.</p>
  <hr />

  
<p>Por tanto, para resumir, los primeros cuatro m&#xe9;todos son casi iguales pero te permiten opcionalmente especificar el environment y/o las propiedades. Aqu&#xed; hay un ejemplo de c&#xf3;mo se construye un SqlSessionFactory desde un fichero mybatis-config.xml.</p>

  
<pre class="prettyprint"><code>String <strong>resource</strong> = &quot;org/mybatis/builder/mybatis-config.xml&quot;;
InputStream <strong>inputStream</strong> = Resources.getResourceAsStream(resource);
SqlSessionFactoryBuilder <strong>builder</strong> = new SqlSessionFactoryBuilder();
SqlSessionFactory <strong>factory</strong> = builder.build(inputStream);</code></pre>

  
<p>Observa que estamos usando la clase de utilidad Resources, que est&#xe1; ubicada en el paquete org.mybatis.io. La clase Resources, tal y como su nombre indica, te ayuda a cargar recursos desde el classpath, el sistema de ficheros o desde una web o URL. Con un vistazo r&#xe1;pido al c&#xf3;digo fuente en tu IDE descubrir&#xe1;s un conjunto bastante obvio de m&#xe9;todos. R&#xe1;pidamente:</p>
  
<pre class="prettyprint"><code>URL getResourceURL(String resource)
URL getResourceURL(ClassLoader loader, String resource)
InputStream getResourceAsStream(String resource)
InputStream getResourceAsStream(ClassLoader loader, String resource)
Properties getResourceAsProperties(String resource)
Properties getResourceAsProperties(ClassLoader loader, String resource)
Reader getResourceAsReader(String resource)
Reader getResourceAsReader(ClassLoader loader, String resource)
File getResourceAsFile(String resource)
File getResourceAsFile(ClassLoader loader, String resource)
InputStream getUrlAsStream(String urlString)
Reader getUrlAsReader(String urlString)
Properties getUrlAsProperties(String urlString)
Class classForName(String className)</code></pre>

  
<p>El &#xfa;ltimo m&#xe9;todo build() recibe una instancia de Configuration. La clase Configuration contiene todo lo que posiblemente necesites conocer de la instancia de SqlSessionFactory. La clase Configuraci&#xf3;n es &#xfa;til para investigar la configuraci&#xf3;n, incluido a&#xf1;adir o modificar SQL maps (no es recomendable una vez la aplicaci&#xf3;n ha comenzado a aceptar peticiones). La clase Configuration tiene todas las opciones de configuraci&#xf3;n que hemos visto ya pero expuestas como una API Java. A continuaci&#xf3;n se muestra un ejemplo simple de c&#xf3;mo instanciar manualmente un objeto Configuration y pasarlo al m&#xe9;todo build() para crear un SqlSessionFactory.</p>
  
<pre class="prettyprint"><code>DataSource dataSource = BaseDataTest.createBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();

Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);

Configuration configuration = new Configuration(environment);
configuration.setLazyLoadingEnabled(true);
configuration.setEnhancementEnabled(true);
configuration.getTypeAliasRegistry().registerAlias(Blog.class);
configuration.getTypeAliasRegistry().registerAlias(Post.class);
configuration.getTypeAliasRegistry().registerAlias(Author.class);
configuration.addMapper(BoundBlogMapper.class);
configuration.addMapper(BoundAuthorMapper.class);

SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
SqlSessionFactory factory = builder.build(configuration);</code></pre>

  
<p>Ahora tienes un SqlSessionFactory, que puede utilizarse para crear interfaces SqlSession.</p>

  
<h4>SqlSessionFactory</h4>
  
<p>SqlSessionFactory tiene seis m&#xe9;todos que se usan para crear instancias de SqlSession. En general, las decisiones que deber&#xe1;s tomar cuando tengas qu&#xe9; elegir de entre alguno de estos m&#xe9;todos son:</p>
  
<ul>
    
<li><strong>Transaction</strong>: &#xbf;Quieres usar un &#xe1;mbito transaccional para esta sesi&#xf3;n o utilizar auto-commit (lo cual equivale a no usar transacci&#xf3;n en la mayor&#xed;a de las bases de datos y/o JDBC drivers)?</li>
    
<li><strong>Connection</strong>: &#xbf;Quieres que MyBatis obtenga una conexi&#xf3;n de un datasource o quieres proporcionar tu propia conexi&#xf3;n?</li>
    
<li><strong>Execution</strong>: &#xbf;Quieres que MyBatis re&#xfa;se PreparedStatements y/o haga batch updates (incluyendo inserts y deletes)?</li>
  </ul>
  
<p>El conjunto de m&#xe9;todos sobrecargados openSession te permiten seleccionar una combinaci&#xf3;n de estas opciones que tenga sentido.</p>
  
<pre class="prettyprint"><code>SqlSession openSession()
SqlSession openSession(boolean autoCommit)
SqlSession openSession(Connection connection)
SqlSession openSession(TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType)
SqlSession openSession(ExecutorType execType, boolean autoCommit)
SqlSession openSession(ExecutorType execType, Connection connection)
Configuration getConfiguration();</code></pre>

  
<p>El m&#xe9;todo openSession() por defecto que recibe par&#xe1;metros crea una SqlSession con las siguientes caracter&#xed;sticas:</p>
  
<ul>
    
<li>Se arranca una transacci&#xf3;n (NO auto-commit)</li>
    
<li>Se obtiene una conexi&#xf3;n de una instancia de DataSource configurada en el environment activo.</li>
    
<li>El nivel de aislamiento transaccional ser&#xe1; el que la base de datos tenga establecido por defecto.</li>
    
<li>No se reusaran PreparedStatements y no se realizar&#xe1;n actualizaciones batch.</li>
  </ul>
  
<p>La mayor&#xed;a de los m&#xe9;todos son auto explicativos. Para habilitar el auto-commit, pasa el valor &#x201c;true&#x201d; al par&#xe1;metro opcional autoCommit. Para proporcionar tu propia conexi&#xf3;n pasa una instancia de conexi&#xf3;n al par&#xe1;metro conexi&#xf3;n. Ten en cuenta que no hay m&#xe9;todo para proporcionar tanto la conexi&#xf3;n como el auto-commit porque MyBatis utilizar&#xe1; las opciones que est&#xe9; usando actualmente la conexi&#xf3;n suministrada. MyBatis usa una enumeration para indicar los niveles de aislamiento denominado TransactionIsolationLevel, pero funcionan como se espera de ellos y tiene los 5 niveles soportados por JDBC (NONE, READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE).</p>
  
<p>El &#xfa;nico par&#xe1;metro que puede ser nuevo para ti es el ExecutorType. Esta enumeraci&#xf3;n define tres valores:</p>
  
<ul>
    
<li><code>ExecutorType.SIMPLE</code>: Este tipo de executor no hace nada en especial. Crea un PreparedStatement para cada sentencia a ejecutar.</li>
    
<li><code>ExecutorType.REUSE</code>: Este tipo de executor reusar&#xe1; PreparedStatements.</li>
    
<li><code>ExecutorType.BATCH</code>: Este executor har&#xe1; batch de todos las sentencias de actualizaci&#xf3;n.</li>
  </ul>
  
<p><span class="label important">NOTE</span> Hay un m&#xe9;todo m&#xe1;s del SqlSessionFactory que no hemos mencionado y es getConfiguration().  Este m&#xe9;todo devuelve una instancia de Configuration que puedes usar para introspeccionar la configuraci&#xf3;n de MyBatis en tiempo de ejecuci&#xf3;n.</p>
  
<p><span class="label important">NOTE</span> Si has usado una versi&#xf3;n anterior de MyBatis recordar&#xe1;s que las sesiones, transacciones y batches eran cosas separadas. Esto ya no es as&#xed;, todas ellas est&#xe1;n contenidas en el interfaz SqlSession. No tienes que gestionar las transacciones o los batches de forma separada para obtener todo su potencial.</p>

  </section><section><a id="SqlSession"></a>
<h4>SqlSession</h4>
  
<p>Como hemos comentado anteriormente, la instancia de SqlSession es la clase m&#xe1;s potente de MyBatis. Es donde encontrar&#xe1;s todos los m&#xe9;todos para ejecutar sentencias, hacer commit o rollback de transacciones y obtener mappers.</p>
  
<p>Hay m&#xe1;s de veinte m&#xe9;todos en la clase SqlSession, as&#xed; que vayamos dividi&#xe9;ndolos en grupo f&#xe1;ciles de digerir.</p>

  <section><a id="M.C3.A9todos_de_ejecuci.C3.B3n_de_sentencias"></a>
<h5>M&#xe9;todos de ejecuci&#xf3;n de sentencias</h5>
  
<p>Estos m&#xe9;todos se usan para ejecutar las sentencias SELECT, INSERT, UPDATE y DELETE que se hayan definido en los ficheros xml de mapeo SQL. Son bastante auto explicativos, cada uno recibe el ID del statement y el objeto de par&#xe1;metro, que puede ser una primitiva, un JavaBean, un POJO o un Map.</p>
  
<pre class="prettyprint"><code>&lt;T&gt; T selectOne(String statement, Object parameter)
&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter)
&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter)
&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey)
int insert(String statement, Object parameter)
int update(String statement, Object parameter)
int delete(String statement, Object parameter)</code></pre>
  
<p>La diferencia entre selectOne y selectList es que selectOne debe devolver s&#xf3;lo un objeto. Si hay m&#xe1;s de uno se lanzar&#xe1; una excepci&#xf3;n. Si no hay ninguno se devolver&#xe1; null. Si no sabes cuantos objetos esperas recibir, usa selectList. Si quieres comprobar la existencia de un objeto ser&#xed;a mejor que devuelvas un count(). SelectMap es un caso especial dise&#xf1;ado para convertir una lista de resultados en un Map basado en las propiedades de los objetos recibidos. Como no todas las sentencias requieren un par&#xe1;metro, estos m&#xe9;todos han sido sobrecargados de forma que se proporcionan versiones que no reciben el par&#xe1;metro objeto.</p>
  
<p>El valor devuelto por los m&#xe9;todos insert, update and delete indica el n&#xfa;mero de filas afectadas por la sentencia.</p>
  
<pre class="prettyprint"><code>&lt;T&gt; T selectOne(String statement)
&lt;E&gt; List&lt;E&gt; selectList(String statement)
&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement)
&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, String mapKey)
int insert(String statement)
int update(String statement)
int delete(String statement)</code></pre>

  
<p>A Cursor offers the same results as a List, except it fetches data lazily using an Iterator.</p>
  
<pre class="prettyprint"><code>try (Cursor&lt;MyEntity&gt; entities = session.selectCursor(statement, param)) {
   for (MyEntity entity:entities) {
      // process one entity
   }
}</code></pre>

  
<p>Finalmente hay tres versiones avanzadas de los m&#xe9;todos select que te permiten restringir el rango de filas devueltas, o proporcionar l&#xf3;gica de tratamiento de resultados personalizada, normalmente para grandes cantidades de datos.</p>
  
<pre class="prettyprint"><code>&lt;E&gt; List&lt;E&gt; selectList (String statement, Object parameter, RowBounds rowBounds)
&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter, RowBounds rowBounds)
&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)
void select (String statement, Object parameter, ResultHandler&lt;T&gt; handler)
void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)</code></pre>

  
<p>El par&#xe1;metro RowBounds hace que MyBatis salte los registros especificados y que limite los resultados devueltos a cierto n&#xfa;mero. La clase RowBounds tiene un constructor que recibe ambos el offset y el limit, y es inmutable.</p>
  
<pre class="prettyprint"><code>int offset = 100;
int limit = 25;
RowBounds rowBounds = new RowBounds(offset, limit);</code></pre>

  
<p>El rendimiento de algunos drivers puede variar mucho en este aspecto. Para un rendimiento optimo, usa tipos de ResultSet SCROLL_SENSITIVE o SCROLL_INSENSITIVE (es decir, no FORWARD_ONLY)</p>
  
<p>El par&#xe1;metro ResultHandler te permite manejar cada fila como t&#xfa; quieras. Puedes a&#xf1;adirla a una lista, crear un Map, un Set, o descartar cada resultado y guardar solo c&#xe1;lculos. Puedes hacer casi todo lo que quieras con un ResultHandler, de hecho, es lo que MyBatis usa internamente para construir listas de ResultSets.</p>
  
<p>Since 3.4.6, ResultHandler passed to a CALLABLE statement is used on every REFCURSOR output parameter of the stored procedure if there is any.</p>
  
<p>La interfaz es muy sencilla:</p>
  
<pre class="prettyprint"><code>package org.apache.ibatis.session;
public interface ResultHandler&lt;T&gt; {
  void handleResult(ResultContext&lt;? extends T&gt; context);
}</code></pre>

  
<p>El par&#xe1;metro ResultContext te da acceso al objeto resultado en s&#xed; mismo, un contador del n&#xfa;mero de objetos creados y un m&#xe9;todo booleano stop() que te permite indicar a MyBatis que pare la carga de datos.</p>

  
<p>Using a ResultHandler has two limitations that you should be aware of:</p>

  
<ul>
  
<li>Data got from an method called with a ResultHandler will not be cached.</li>
  
<li>When using advanced resultmaps MyBatis will probably require several rows to build an object. If a ResultHandler is used you may be given an object whose associations or collections are not yet filled.</li>
  </ul>

  </section><section><a id="Batch_update_statement_Flush_Method"></a>
<h5>Batch update statement Flush Method</h5>
  
<p>There is method for flushing(executing) batch update statements that stored in a JDBC driver class at any timing. This method can be used when you use the <code>ExecutorType.BATCH</code> as <code>ExecutorType</code>.</p>
  
<pre class="prettyprint"><code>List&lt;BatchResult&gt; flushStatements()</code></pre>

  </section><section><a id="M.C3.A9todos_de_control_de_transacci.C3.B3n"></a>
<h5 id="transaction-control-methods">M&#xe9;todos de control de transacci&#xf3;n</h5>
  
<p>El par&#xe1;metro ResultContext te da acceso al objeto resultado en s&#xed; mismo, un contador del n&#xfa;mero de objetos creados y un m&#xe9;todo booleano stop() que te permite indicar a MyBatis que pare la carga de datos.</p>
  
<pre class="prettyprint"><code>void commit()
void commit(boolean force)
void rollback()
void rollback(boolean force)</code></pre>
  
<p>Por defecto MyBatis no hace un commit a no ser que haya detectado que la base de datos ha sido modificada por una insert, update, delete o select con <code>affectData</code> habilitado. Si has realizado cambios sin llamar a estos m&#xe9;todos, entonces puedes pasar true en al m&#xe9;todo de commit() y rollback() para asegurar que se realiza el commit (ten en cuenta que aun as&#xed; no puedes forzar el commit() en modo auto-commit o cuando se usa un gestor de transacciones externo). La mayor&#xed;a de las veces no tendr&#xe1;s que llamar a rollback() dado que MyBatis lo har&#xe1; por ti en caso de que no hayas llamado a commit(). Sin embargo, si necesitas un control m&#xe1;s fino sobre la sesi&#xf3;n, donde puede que haya varios commits, tienes esta opci&#xf3;n para hacerlo posible.</p>
  
<p><span class="label important">NOTA</span> MyBatis-Spring y MyBatis-Guice proporcionan gesti&#xf3;n de transacci&#xf3;n declarativa. Por tanto si est&#xe1;s usando MyBatis con Spring o Guice consulta sus manuales espec&#xed;ficos.</p>

  </section><section><a id="Local_Cache"></a>
<h5>Local Cache</h5>
  
<p>MyBatis utliza dos cach&#xe9;s: la cach&#xe9; local y la cach&#xe9; de segundo nivel.</p>
  
<p>Cada vez que se crea una sesi&#xf3;n MyBatis crea una cache local y la asocia a dicha sesi&#xf3;n. Cualquier query que se ejecute en la sesi&#xf3;n ser&#xe1; cacheada de forma que si en el futuro se vuelve a lanzar la misma query con los mismos par&#xe1;metros de entrada los datos se obtendr&#xe1;n de la cach&#xe9; y no se acceder&#xe1; a la base de datos. La cach&#xe9; local se vac&#xed;a cuando se ejecuta cupdate, commit, rollback y close.</p>
  
<p>Por defecto la cache local se utiliza durante toda la duraci&#xf3;n de la sesi&#xf3;n. Esta cache es necesaria para resolver dependencias circulares y para acelerar consultas anidadas repetidas asi que no puede desactivarse, pero puede configurarse para que se utilize s&#xf3;lo durante la duraci&#xf3;n de la ejecuci&#xf3;n de una sentencia infomando el par&#xe1;metro de configuraci&#xf3;n localCacheScope=STATEMENT.</p>
  
<p>Cuando localCacheScope est&#xe1; informado a SESSION (valor por defecto) MyBatis devuelve referencias a objetos objetos almacenados en la cach&#xe9;. Cualquier modificaci&#xf3;n de un objeto (listas etc.) influye en el contenido de la cach&#xe9; y en los valores que ser&#xe1;n retornados posteriormente durante la existencia de la sessi&#xf3;n. Por lo tanto, como mejor pr&#xe1;ctica, evita modificaciones sobre los objetos devueltos por MyBatis.</p>
  
<p>Puedes borrar el contenido de la cach&#xe9; local en el momento que desees invocando:</p>
  
<pre class="prettyprint"><code>void clearCache()</code></pre>

  </section><section><a id="Asegurarse_de_que_la_SqlSession_se_cierra"></a>
<h5>Asegurarse de que la SqlSession se cierra</h5>
  
<pre class="prettyprint"><code>void close()</code></pre>
  
<p>El punto m&#xe1;s importante del que debes asegurarte es que cierras todas las sesiones que abres. La mejor forma de asegurarse es usar el patr&#xf3;n mostrado a continuaci&#xf3;n:</p>
  
<pre class="prettyprint"><code>try (SqlSession session = sqlSessionFactory.openSession()) {
    // following 3 lines pseudocod for &quot;doing some work&quot;
    session.insert(...);
    session.update(...);
    session.delete(...);
    session.commit();
}</code></pre>
  
<p><span class="label important">NOTE</span> Al igual que con SqlSessionFactory, puedes obtener la instancia de Configuration que est&#xe1; usando al SqlSession llamando al m&#xe9;todo getConfiguration().</p>
  
<pre class="prettyprint"><code>Configuration getConfiguration()</code></pre>

  </section><section><a id="Uso_de_Mappers"></a>
<h5>Uso de Mappers</h5>
  
<pre class="prettyprint"><code>&lt;T&gt; T getMapper(Class&lt;T&gt; type)</code></pre>
  
<p>Aunque los m&#xe9;todos insert, update, delete y select son potentes, tambi&#xe9;n son muy verbosos, no hay seguridad de tipos (type safety) y no son tan apropiados para tu IDE o tus pruebas unitarias como pudieran ser. Ya hemos visto un ejemplo de uso de mappers en la secci&#xf3;n de primeros pasos.</p>
  
<p>Por lo tanto, una forma m&#xe1;s com&#xfa;n de ejecutar mapped statements es utilizar clases Mapper. Un mapper es simplemente una interfaz con definiciones de m&#xe9;todos que se hacen encajar con m&#xe9;todos de SqlSession. El ejemplo siguiente demuestra algunas firmas de m&#xe9;todo y como se asignan a una SqlSession.</p>
  
<pre class="prettyprint"><code>public interface AuthorMapper {
  // (Author) selectOne(&quot;selectAuthor&quot;,5);
  Author selectAuthor(int id);
  // (List&lt;Author&gt;) selectList(&#x201c;selectAuthors&#x201d;)
  List&lt;Author&gt; selectAuthors();
  // (Map&lt;Integer,Author&gt;) selectMap(&quot;selectAuthors&quot;, &quot;id&quot;)
  @MapKey(&quot;id&quot;)
  Map&lt;Integer, Author&gt; selectAuthors();
  // insert(&quot;insertAuthor&quot;, author)
  int insertAuthor(Author author);
  // updateAuthor(&quot;updateAuthor&quot;, author)
  int updateAuthor(Author author);
  // delete(&quot;deleteAuthor&quot;,5)
  int deleteAuthor(int id);
}</code></pre>
  
<p>En resumen, cada firma de m&#xe9;todo de mapper se asigna al m&#xe9;todo de la SqlSession al que est&#xe1; asociado pero sin par&#xe1;metro ID. En su lugar el nombre del m&#xe9;todo debe ser el mismo que el ID del mapped statement.</p>
  
<p>Adem&#xe1;s, el tipo devuelto debe ser igual que el result type del mapped statement. Todos los tipos habituales se soportan, incluyendo primitivas, mapas, POJOs y JavaBeans.</p>
  
<p><span class="label important">NOTA</span> Los mappers no necesitan implementar ninguna interfaz o extender ninguna clase. S&#xf3;lo es necesario que la firma de m&#xe9;todo pueda usarse para identificar un&#xed;vocamente el mapped statement correspondiente.</p>
  
<p><span class="label important">NOTA</span> Los mappers pueden extender otras interfaces. Aseg&#xfa;rate que tienes tus statements en los namespaces adecuados en tu fichero XML. Adem&#xe1;s, la &#xfa;nica limitaci&#xf3;n es que no puedes tener el mismo m&#xe9;todo, con la misma firma, en dos interfaces de la jerarqu&#xed;a (una mala idea en cualquier caso).</p>
  
<p>Puedes pasar m&#xe1;s de un par&#xe1;metro a un m&#xe9;todo de un mapper. Si lo haces, se usar&#xe1; como nombre el literal &quot;param&quot; seguido de su posici&#xf3;n en la lista de par&#xe1;metros, por ejemplo:  #{param1}, #{param2} etc. Si quieres cambiar su nombre (solo en caso de par&#xe1;metros m&#xfa;ltiples) puedes usar la notaci&#xf3;n @Param(&#x201c;paramName&#x201d;).</p>
  
<p>Tambi&#xe9;n puedes pasar una instancia de RowBounds al m&#xe9;todo para limitar los resultados.</p>

  </section><section><a id="Anotaciones_de_mappers"></a>
<h5>Anotaciones de mappers</h5>
  
<p>Desde sus comienzos, MyBatis ha sido siempre un framework XML. La configuraci&#xf3;n se basa en XML y los mapped statements se definen en XML. Con MyBatis 3, hay m&#xe1;s opciones. MyBatis 3 se ha desarrollado sobre una exhaustiva y potente API de configuraci&#xf3;n Java. Este API es el fundamento de la configuraci&#xf3;n basada en XML y tambi&#xe9;n de la nueva configuraci&#xf3;n basada en anotaciones. Las anotaciones simplemente ofrecen una forma m&#xe1;s sencilla de implementar los mapped statements sin introducir un mont&#xf3;n de sobrecarga.</p>
  
<p><span class="label important">NOTE</span> Las anotaciones Java son desafortunadamente muy  limitadas en su flexibilidad y expresividad. A pesar de haber dedicado mucho tiempo a la investigaci&#xf3;n, dise&#xf1;o y pruebas, los mapeos m&#xe1;s potentes de MyBatis simplemente no es posible construirlos con anotaciones. Los atributos C# (por ejemplo) no sufren de las mismas limitaciones y por tanto MyBatis.NET podr&#xe1; construir una alternativa mucho m&#xe1;s rica al XML. Dicho esto, la configuraci&#xf3;n basada en anotaciones Java tambi&#xe9;n tiene sus ventajas.</p>
  
<p><strong>Las anotaciones son las siguientes:</strong></p>
  
<table class="table table-striped">
    <thead>
      
<tr class="a">
        
<th>Anotaci&#xf3;n</th>
        
<th>Target</th>
        
<th>XML equivalente</th>
        
<th>Descripci&#xf3;n</th>
      </tr>
    </thead>
    <tbody>
      
<tr class="b">
        
<td><code>@CacheNamespace</code></td>
        
<td><code>Class</code></td>
        
<td><code>&lt;cache&gt;</code></td>
        
<td>Configura la cache para un namespace (una clase). Atributos: implementation, eviction, flushInterval, size, readWrite, blocking and properties.</td>
      </tr>
      
<tr class="a">
        
<td><code>@Property</code></td>
        
<td>N/A</td>
        
<td><code>&lt;property&gt;</code></td>
        
<td>Specifies the property value or placeholder(can replace by configuration properties that defined at the <code>mybatis-config.xml</code>). Attributes: <code>name</code>, <code>value</code>. (Available on MyBatis 3.4.2+)</td>
      </tr>
      
<tr class="b">
        
<td><code>@CacheNamespaceRef</code></td>
        
<td><code>Class</code></td>
        
<td><code>&lt;cacheRef&gt;</code></td>
        
<td>
          Referencia una cache de otro namespace. Note that caches declared in an XML mapper file are considered a separate namespace, even if they share the same FQCN. Atributos: <code>value</code> and <code>name</code>.
          If you use this annotation, you should be specified either <code>value</code> or <code>name</code> attribute.
          For the <code>value</code> attribute specify a java type indicating the namespace(the namespace name become a FQCN of specified java type),
          and for the <code>name</code> attribute(this attribute is available since 3.4.2) specify a name indicating the namespace.
        </td>
      </tr>
      
<tr class="a">
        
<td><code>@ConstructorArgs</code></td>
        
<td><code>Method</code></td>
        
<td><code>&lt;constructor&gt;</code></td>
        
<td>Agrupa un conjunto de resultados que ser&#xe1;n pasados al constructor de un objeto de resultado. Atributos: value, que es un array de Args.</td>
      </tr>
      
<tr class="b">
        
<td><code>@Arg</code></td>
        
<td>N/A</td>
        
<td>
          
<ul>
            
<li><code>&lt;arg&gt;</code></li>
            
<li><code>&lt;idArg&gt;</code></li>
          </ul>
        </td>
        
<td>Un argumento que es parte de un  ConstructorArgs.  Atributos:  id, column, javaType, jdbcType, typeHandler, select and resultMap.  El atributo id es un valor booleano que identifica la propiedad que ser&#xe1; usada en las comparaciones, parecido al elemento XML &lt;idArg&gt;. Since 3.5.4, it can be used as repeatable annotation.</td>
      </tr>
      
<tr class="a">
        
<td><code>@TypeDiscriminator</code></td>
        
<td><code>Method</code></td>
        
<td><code>&lt;discriminator&gt;</code></td>
        
<td>Un grupo de clases que se pueden usar para determinar que mapeo de resultados realizar. Atributos:  column, javaType, jdbcType, typeHandler, cases.  El atributo cases es un array de Cases.</td>
      </tr>
      
<tr class="b">
        
<td><code>@Case</code></td>
        
<td>N/A</td>
        
<td><code>&lt;case&gt;</code></td>
        
<td>Un caso concreto y su mapeo correspondiente. Atributos: value, type, results.  El atributo results es un array de Results, por tanto esta anotaci&#xf3;n Case es similar a un ResultMap, que se especifica mediante la anotaci&#xf3;n Results a continuaci&#xf3;n.</td>
      </tr>
      
<tr class="a">
        
<td><code>@Results</code></td>
        
<td><code>Method</code></td>
        
<td><code>&lt;resultMap&gt;</code></td>
        
<td>Una lista de  Result mapping que contiene los detalles de c&#xf3;mo una columna particular se mapea a una propiedad o campo. Atributos: value, id. El atributo value es un array de anotaciones Result. The id attribute is the name of the result mapping.</td>
      </tr>
      
<tr class="b">
        
<td><code>@Result</code></td>
        
<td>N/A</td>
        
<td>
          
<ul>
            
<li><code>&lt;result&gt;</code></li>
            
<li><code>&lt;id&gt;</code></li>
          </ul>
        </td>
        
<td>Un result mapping entre una columna y una propiedad o campo. Atributos: :  id, column, property, javaType, jdbcType, typeHandler, one, many.  El atributo id es un valor booleano que indica que la propiedad debe usarse en comparaciones (similar al &lt;id&gt; de los mapeos XML). El atributo one sirve para asociaciones de simples, similar al &lt;association&gt;, y el atributo many es para colecciones, similar al &lt;collection&gt;. Sus denominaciones son tales para evitar conflictos con nombres de clases. Since 3.5.4, it can be used as repeatable annotation.</td>
      </tr>
      
<tr class="a">
        
<td><code>@One</code></td>
        
<td>N/A</td>
        
<td><code>&lt;association&gt;</code></td>
        
<td>
        Un mapeo a una propiedad que contiene un tipo complejo. Atributos: select, que contiene el nombre completamente cualificado de un mapped statement (o un m&#xe9;todo de mapper) que puede cargar la instancia del tipo indicado.
        <code>fetchType</code>, que sobrescribe el par&#xe1;metro global de configuraci&#xf3;n <code>lazyLoadingEnabled</code> para este mapeo.
        <code>resultMap</code>(available since 3.5.5), which is the fully qualified name of a result map that map to a single container object from select result.
        <code>columnPrefix</code>(available since 3.5.5), which is column prefix for grouping select columns at nested result map.
        Nota: Habr&#xe1;s visto que el mapeo de tipo join no se soporta mediante el API de anotaciones. Esto es debido a las limitaciones de las anotaciones en Java que no permiten referencias circulares.</td>
      </tr>
      
<tr class="b">
        
<td><code>@Many</code></td>
        
<td>N/A</td>
        
<td><code>&lt;collection&gt;</code></td>
        
<td>Un mapeo a una propiedad que contiene una colecci&#xf3;n de tipos complejos. Atributos: select, que contiene el nombre completamente cualificado de un mapped statement (o un m&#xe9;todo de mapper) que puede cargar la instancia del tipo indicado.
        <code>fetchType</code>, que sobrescribe el par&#xe1;metro global de configuraci&#xf3;n <code>lazyLoadingEnabled</code> para este mapeo.
        <code>resultMap</code>(available since 3.5.5), which is the fully qualified name of a result map that map to collection object from select result.
        <code>columnPrefix</code>(available since 3.5.5), which is column prefix for grouping select columns at nested result map.
        Nota: Habr&#xe1;s visto que el mapeo de tipo join no se soporta mediante el API de anotaciones. Esto es debido a las limitaciones de las anotaciones en Java que no permiten referencias circulares.</td>
      </tr>
      
<tr class="a">
        
<td><code>@MapKey</code></td>
        
<td><code>Method</code></td>
        
<td> </td>
        
<td>Se usa en m&#xe9;todos cuyo tipo de retorno es Map. Se usa para convertir una Lista de objetos de resultado a un Map bas&#xe1;ndose en una propiedad de dichos objetos.</td>
      </tr>
      
<tr class="b">
        
<td><code>@Options</code></td>
        
<td><code>Method</code></td>
        
<td>Attributes of mapped statements.</td>
        
<td>
          Esta anotaci&#xf3;n proporciona acceso a un gran conjunto de opciones de configuraci&#xf3;n que normalmente aparecen como atributos en los mapped statements.
          En lugar de complicar cada anotaci&#xf3;n existente la anotaci&#xf3;n Options proporciona una forma sencilla y concisa de acceder a estas opciones.
          Atributos: useCache=true, flushCache=FlushCachePolicy.DEFAULT, resultSetType=DEFAULT, statementType=PREPARED, fetchSize=-1, timeout=-1, useGeneratedKeys=false, keyProperty=&#x201c;&#x201d;, keyColumn=&#x201c;&#x201d;, resultSets=&#x201c;&#x201d;, databaseId=&quot;&quot;.
          Es importante comprender que las anotaciones en Java no permiten indicar un valor nulo.
          Por lo tanto, cuando usas la anotaci&#xf3;n Options el statement usar&#xe1; todos los valores por defecto.
          Presta atenci&#xf3;n a estos valores pro defecto para evitar comportamientos inesperados.
          The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>,
          the MyBatis use the <code>Options</code> with no <code>databaseId</code> attribute or with a <code>databaseId</code>
          that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded.<br /><br />

          La keyColumn solo se requiere para algunas bases de datos (como PostgreSQL) cuando la columna no es la primera columna de la tabla.
        </td>
      </tr>
      
<tr class="a">
        
<td>
          
<ul>
            
<li><code>@Insert</code></li>
            
<li><code>@Update</code></li>
            
<li><code>@Delete</code></li>
            
<li><code>@Select</code></li>
          </ul>
        </td>
        
<td><code>Method</code></td>
        
<td>
          
<ul>
            
<li><code>&lt;insert&gt;</code></li>
            
<li><code>&lt;update&gt;</code></li>
            
<li><code>&lt;delete&gt;</code></li>
            
<li><code>&lt;select&gt;</code></li>
          </ul>
        </td>
        
<td>
          Cada una de estas anotaciones representa el SQL que debe ejecutarse. Cada una de ellas recibe un array de strings (o un solo string).
          Si se pasa un array de strings, todos ellos se concatenar&#xe1;n introduciendo un espacio en blanco entre ellos.
          Esto ayuda a evitar el problema &#x201c;falta un espacio en blanco&#x201d; al construir SQL en c&#xf3;digo Java. Sin embargo, tambi&#xe9;n puedes concatenarlos en un solo string si lo prefieres.
          Atributos: value, que es el array de String para formar una &#xfa;nica sentencia SQL.
          The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>,
          the MyBatis use a statement with no <code>databaseId</code> attribute or with a <code>databaseId</code>
          that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded.
        </td>
      </tr>
      
<tr class="b">
        
<td>
          
<ul>
            
<li><code>@InsertProvider</code></li>
            
<li><code>@UpdateProvider</code></li>
            
<li><code>@DeleteProvider</code></li>
            
<li><code>@SelectProvider</code></li>
          </ul>
        </td>
        
<td><code>Method</code></td>
        
<td>
          
<ul>
            
<li><code>&lt;insert&gt;</code></li>
            
<li><code>&lt;update&gt;</code></li>
            
<li><code>&lt;delete&gt;</code></li>
            
<li><code>&lt;select&gt;</code></li>
          </ul>
        </td>
        
<td>Estas anotaciones SQL alternativas te permiten especificar un nombre de clases y un m&#xe9;todo que devolver&#xe1;n la SQL que debe ejecutarse (Since 3.4.6, you can specify the <code>CharSequence</code> instead of <code>String</code> as a method return type).
          Cuando se ejecute el m&#xe9;todo MyBatis instanciar&#xe1; la clase y ejecutar&#xe1; el m&#xe9;todo especificados en el provider. You can pass objects that passed to arguments of a mapper method, &quot;Mapper interface type&quot;, &quot;Mapper method&quot; and &quot;Database ID&quot;
          via the <code>ProviderContext</code>(available since MyBatis 3.4.5 or later) as method argument.(In MyBatis 3.4 or later, it's allow multiple parameters)
          Atributos: value, type y method.
          El atributo value y type es el nombre completamente cualificado de una clase
          (The <code>type</code> attribute is alias for <code>value</code>, you must be specify either one.
          But both attributes can be omit when specify the <code>defaultSqlProviderType</code> as global configuration).
          El method es el nombre un m&#xe9;todo de dicha clase
          (Since 3.5.1, you can omit <code>method</code> attribute, the MyBatis will resolve a target method via the
          <code>ProviderMethodResolver</code> interface.
          If not resolve by it, the MyBatis use the reserved fallback method that named <code>provideSql</code>).
          The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>,
          the MyBatis will use a provider method with no <code>databaseId</code> attribute or with a <code>databaseId</code>
          that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded.

          Nota: A continuaci&#xf3;n hay una secci&#xf3;n sobre la clase, que puede ayudar a construir SQL din&#xe1;mico de una forma m&#xe1;s clara y sencilla de leer.</td>
      </tr>
      
<tr class="a">
        
<td><code>@Param</code></td>
        
<td><code>Parameter</code></td>
        
<td>N/A</td>
        
<td>Si tu mapper recibe par&#xe1;metros m&#xfa;ltiples, esta anotaci&#xf3;n puede aplicarse a cada par&#xe1;metro para proporcionarle un nombre. En caso contrario, los par&#xe1;metros m&#xfa;ltiples se nombrar&#xe1;n seg&#xfa;n su posici&#xf3;n (sin incluir el par&#xe1;metro RowBounds), prefijados con &quot;param&quot;. Por ejemplo:  #{param1}, #{param2} etc. es el defecto.  Con @Param(&#x201c;persona&#x201d;), el par&#xe1;metro se llamar&#xe1; #{persona}.</td>
      </tr>
      
<tr class="b">
        
<td><code>@SelectKey</code></td>
        
<td><code>Method</code></td>
        
<td><code>&lt;selectKey&gt;</code></td>
        
<td>
          Esta anotaci&#xf3;n es igual que la &lt;selectKey&gt; para m&#xe9;todos anotados con @Insert, @InsertProvider, @Update o @UpdateProvider.
          Se ignora en otros m&#xe9;todos. Si especificas la anotaci&#xf3;n @SelectKey, entonces MyBatis ignorar&#xe1; todas las propiedades de generaci&#xf3;n de claves proporcionadas por la anotaci&#xf3;n @Options, o mediante propiedades de configuraci&#xf3;n.
          Atributos: statement un array de strings que contienen la SQL a ejecutar, keyProperty que es la propiedad del objeto par&#xe1;metro que se actualizar&#xe1; con el Nuevo valor,
          before que debe valer true o false para indicar si la sentencia SQL debe ejecutarse antes o despu&#xe9;s de la insert, resultType que es el tipo de la propiedad keyProperty, y statementType=PREPARED.
          The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>,
          the MyBatis will use a statement with no <code>databaseId</code> attribute or with a <code>databaseId</code>
          that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded.
        </td>
      </tr>
      
<tr class="a">
        
<td><code>@ResultMap</code></td>
        
<td><code>Method</code></td>
        
<td>N/A</td>
        
<td>Esta anotaci&#xf3;n se usa para proporcionar el id de un elemento &lt;resultMap&gt; en un mapper XML a una anotaci&#xf3;n @Select o @SelectProvider. Esto permite a las selects anotadas reusar resultmaps definidas en XML. Esta anotaci&#xf3;n sobrescribe las anotaciones @Result o @ConstructorArgs en caso de que se hayan especificado en la select anotada.</td>
      </tr>
      
<tr class="b">
        
<td><code>@ResultType</code></td>
        
<td><code>Method</code></td>
        
<td>N/A</td>
        
<td>Esta anotaci&#xf3;n se usa cuando se utiliza un result handler. En ese caso, el tipo devuelto por el m&#xe9;todo es void y
        MyBatis no puede determinar el tipo del objeto que debe construir para cada fila.
        Si hay un result map XML entonces se utiliza la anotaci&#xf3;n @ResultMap. Si el tipo de retorno se especifica en el
        elemento <code>&lt;select&gt;</code> del XML entonces no es necesaria ninguna otra anotaci&#xf3;n.
        En el resto de casos, usa esta anotaci&#xf3;n. Por ejemplo en un m&#xe9;todo anotado con @Select con un result handler
        el valor de retorno ser&#xe1; void y por tanto se requiere incluir esta anotaci&#xf3;n (o @ResultMap).
        La anotaci&#xf3;n se ignora si el tipo devuelto por el m&#xe9;otdo no es void.</td>
      </tr>
      
<tr class="a">
        
<td><code>@Flush</code></td>
        
<td><code>Method</code></td>
        
<td>N/A</td>
        
<td>If this annotation is used, it can be called the <code>SqlSession#flushStatements()</code> via method defined at a Mapper interface.(MyBatis 3.3 or above)</td>
      </tr>
    </tbody>
  </table>

  </section><section><a id="Ejemplos_de_mappers_anotados"></a>
<h5>Ejemplos de mappers anotados</h5>
  
<p>Este ejemplo muestra como se usa la anotaci&#xf3;n @SelectKey para obtener un valor de una secuencia antes de de una insert:</p>
  
<pre class="prettyprint"><code>@Insert(&quot;insert into table3 (id, name) values(#{nameId}, #{name})&quot;)
@SelectKey(statement=&quot;call next value for TestSequence&quot;, keyProperty=&quot;nameId&quot;, before=<strong>true</strong>, resultType=<strong>int.class</strong>)
<strong>int</strong> insertTable3(Name name);</code></pre>

  
<p>Este ejemplo muestra como se usa la anotaci&#xf3;n @SelectKey para obtener el valor de una identity despu&#xe9;s de una insert:</p>
  
<pre class="prettyprint"><code>@Insert(&quot;insert into table2 (name) values(#{name})&quot;)
@SelectKey(statement=&quot;call identity()&quot;, keyProperty=&quot;nameId&quot;, before=<strong>false</strong>, resultType=<strong>int.class</strong>)
<strong>int</strong> insertTable2(Name name);</code></pre>

  
<p>This example shows using the <code>@Flush</code> annotation to call the <code>SqlSession#flushStatements()</code>:</p>
  
<pre class="prettyprint"><code>@Flush
List&lt;BatchResult&gt; flush();</code></pre>

  
<p>These examples show how to name a ResultMap by specifying id attribute of @Results annotation.</p>
  
<pre class="prettyprint"><code>@Results(id = &quot;userResult&quot;, value = {
  @Result(property = &quot;id&quot;, column = &quot;uid&quot;, id = <strong>true</strong>),
  @Result(property = &quot;firstName&quot;, column = &quot;first_name&quot;),
  @Result(property = &quot;lastName&quot;, column = &quot;last_name&quot;)
})
@Select(&quot;select * from users where id = #{id}&quot;)
User getUserById(Integer id);

@Results(id = &quot;companyResults&quot;)
@ConstructorArgs({
  @Arg(column = &quot;cid&quot;, javaType = Integer.class, id = <strong>true</strong>),
  @Arg(column = &quot;name&quot;, javaType = String.class)
})
@Select(&quot;select * from company where id = #{id}&quot;)
Company getCompanyById(Integer id);</code></pre>

  
<p>This example shows solo parameter using the Sql Provider annotation:</p>
  
<pre class="prettyprint"><code>@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)
List&lt;User&gt; getUsersByName(String name);

class UserSqlBuilder {
  public static String buildGetUsersByName(final String name) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      if (name != null) {
        WHERE(&quot;name like #{value} || '%'&quot;);
      }
      ORDER_BY(&quot;id&quot;);
    }}.toString();
  }
}</code></pre>

  
<p>This example shows multiple parameters using the Sql Provider annotation:</p>
  
<pre class="prettyprint"><code>@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)
List&lt;User&gt; getUsersByName(
    @Param(&quot;name&quot;) String name, @Param(&quot;orderByColumn&quot;) String orderByColumn);

class UserSqlBuilder {

  // If not use @Param, you should be define same arguments with mapper method
  public static String buildGetUsersByName(
      final String name, final String orderByColumn) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      WHERE(&quot;name like #{name} || '%'&quot;);
      ORDER_BY(orderByColumn);
    }}.toString();
  }

  // If use @Param, you can define only arguments to be used
  public static String buildGetUsersByName(@Param(&quot;orderByColumn&quot;) final String orderByColumn) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      WHERE(&quot;name like #{name} || '%'&quot;);
      ORDER_BY(orderByColumn);
    }}.toString();
  }
}</code></pre>

    
<p>This example shows usage the default implementation of <code>ProviderMethodResolver</code>(available since MyBatis 3.5.1 or later):</p>
    
<pre class="prettyprint"><code>@SelectProvider(type = UserSqlProvider.class)
List&lt;User&gt; getUsersByName(String name);

// Implements the ProviderMethodResolver on your provider class
class UserSqlProvider implements ProviderMethodResolver {
  // In default implementation, it will resolve a method that method name is matched with mapper method
  public static String getUsersByName(final String name) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      if (name != null) {
        WHERE(&quot;name like #{value} || '%'&quot;);
      }
      ORDER_BY(&quot;id&quot;);
    }}.toString();
  }
}</code></pre>

    
<p>This example shows usage that share an sql provider class to all mapper methods using global configuration(Available since 3.5.6):</p>
    
<pre class="prettyprint"><code>
Configuration configuration = new Configuration();
configuration.setDefaultSqlProviderType(TemplateFilePathProvider.class); // Specify an sql provider class for sharing on all mapper methods
// ...</code></pre>
    
<pre class="prettyprint"><code>
// Can omit the type/value attribute on sql provider annotation
// If omit it, the MyBatis apply the class that specified on defaultSqlProviderType.
public interface UserMapper {

  @SelectProvider // Same with @SelectProvider(TemplateFilePathProvider.class)
  User findUser(int id);

  @InsertProvider // Same with @InsertProvider(TemplateFilePathProvider.class)
  void createUser(User user);

  @UpdateProvider // Same with @UpdateProvider(TemplateFilePathProvider.class)
  void updateUser(User user);

  @DeleteProvider // Same with @DeleteProvider(TemplateFilePathProvider.class)
  void deleteUser(int id);
}</code></pre>

    
<p>This example shows usage the default implementation of <code>ProviderMethodResolver</code>(available since MyBatis 3.5.1 or later):</p>
    
<pre class="prettyprint"><code>@SelectProvider(UserSqlProvider.class)
List&lt;User&gt; getUsersByName(String name);

// Implements the ProviderMethodResolver on your provider class
class UserSqlProvider implements ProviderMethodResolver {
  // In default implementation, it will resolve a method that method name is matched with mapper method
  public static String getUsersByName(final String name) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      if (name != null) {
        WHERE(&quot;name like #{value} || '%'&quot;);
      }
      ORDER_BY(&quot;id&quot;);
    }}.toString();
  }
}</code></pre>

    
<p>This example shows usage the <code>databaseId</code> attribute on the statement annotation(Available since 3.5.5):</p>
    
<pre class="prettyprint"><code>
@Select(value = &quot;SELECT SYS_GUID() FROM dual&quot;, databaseId = &quot;oracle&quot;) // Use this statement if DatabaseIdProvider provide &quot;oracle&quot;
@Select(value = &quot;SELECT uuid_generate_v4()&quot;, databaseId = &quot;postgres&quot;) // Use this statement if DatabaseIdProvider provide &quot;postgres&quot;
@Select(&quot;SELECT RANDOM_UUID()&quot;) // Use this statement if the DatabaseIdProvider not configured or not matches databaseId
String generateId();
</code></pre>

  </section></section></section></section>

  </section>
  

        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2009–2024
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>
