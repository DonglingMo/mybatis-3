<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0-M19 from src/site/es/xdoc/sqlmap-xml.xml at 27 noviembre 2024
 | Rendered using Apache Maven Fluido Skin 2.0.0-M9
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0-M19" />
    <meta name="author" content="Clinton Begin" />
    <meta name="author" content="Eduardo Macarron" />
    <title>MyBatis 3 | Ficheros XML de mapeo – mybatis</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M9.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M9.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"><div id="bannerRight"><h1><a href="https://blog.mybatis.org/" class="externalLink"><img class="imageLink" src="../../images/mybatis-logo.png" alt="MyBatis logo" /> MyBatis</a></h1></div></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Publicado el: 26 noviembre 2024<span class="divider">|</span>
</li>
          <li id="projectVersion">Versión: 3.5.17</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Manual de Referencia</li>
    <li><a href="index.html">Introducción</a></li>
    <li><a href="getting-started.html">Primeros pasos</a></li>
    <li><a href="configuration.html"><span class="icon-chevron-right"></span>Configuración</a></li>
    <li class="active"><a><span class="icon-chevron-down"></span>Ficheros XML de mapeo</a>
     <ul class="nav nav-list">
      <li><a href="sqlmap-xml.html#select">select</a></li>
      <li><a href="sqlmap-xml.html#insert_update_and_delete">insert, update and delete</a></li>
      <li><a href="sqlmap-xml.html#Parameters">Parameters</a></li>
      <li><a href="sqlmap-xml.html#Result_Maps">Result Maps</a></li>
      <li><a href="sqlmap-xml.html#Auto-mapeo">Auto-mapeo</a></li>
      <li><a href="sqlmap-xml.html#cache">cache</a></li>
     </ul></li>
    <li><a href="dynamic-sql.html">SQL dinámico</a></li>
    <li><a href="java-api.html"><span class="icon-chevron-right"></span>Java API</a></li>
    <li><a href="statement-builders.html">La clase SQL</a></li>
    <li><a href="logging.html">Logging</a></li>
   <li class="nav-header">Documentación del proyecto</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Información del proyecto</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-right"></span>Informes del proyecto</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Generado por Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">


  
    <section><a id="Ficheros_XML_de_mapeo"></a>
<h1>Ficheros XML de mapeo</h1>
      
<p>La potencia de MyBatis reside en los Mapped Statements. Aqu&#xed; es donde est&#xe1; la magia. Para lo potentes que son, los ficheros XML de mapeo son relativamente simples. Sin duda, si los comparas con el c&#xf3;digo JDBC equivalente comprobar&#xe1;s que ahorras el 95% del c&#xf3;digo.
      </p>
      
<p>Los ficheros XML de mapeos SQL solo tienen unos pocos elementos de alto nivel (en el orden en el que deber&#xed;an definirse):
      </p>
      
<ul>
        
<li>
          <code>cache</code>
          &#x2013; Configuraci&#xf3;n de la cach&#xe9; para un namespace.
        </li>
        
<li>
          <code>cache-ref</code>
          &#x2013; Referencia a la cach&#xe9; de otro namespace.
        </li>
        
<li>
          <code>resultMap</code>
          &#x2013; El elemento m&#xe1;s complejo y potente que describe como cargar tus objetos a partir de los ResultSets.
        </li>
        
<li>
          <del>
            <code>parameterMap</code>
            &#x2013; Deprecada!  Antigua forma de mapear par&#xe1;metros. Se recomienda el uso de par&#xe1;metros en l&#xed;nea. Este elemento puede ser eliminado en futuras versiones. No se ha documentado en este manual.
          </del>
        </li>
        
<li>
          <code>sql</code>
          &#x2013; Un trozo de SQL reusable que puede utilizarse en otras sentencias.
        </li>
        
<li>
          <code>insert</code>
          &#x2013; Una sentencia INSERT.
        </li>
        
<li>
          <code>update</code>
          &#x2013; A Una sentencia UPDATE.
        </li>
        
<li>
          <code>delete</code>
          &#x2013; Una sentencia DELETE.
        </li>
        
<li>
          <code>select</code>
          &#x2013; Una sentencia SELECT.
        </li>
      </ul>
      
<p>Las siguientes secciones describen estos elementos en detalle, comenzando con los propios elementos.
      </p>

      <section><a id="select"></a>
<h2>select</h2>
        
<p>El select statement es uno de los elementos que m&#xe1;s utilizar&#xe1;s en MyBatis. No es demasiado &#xfa;til almacenar datos en la base de datos si no puedes leerlos, de hecho las aplicaciones suelen leer bastantes m&#xe1;s datos de los que modifican. Por cada insert, update o delete posiblemente haya varias selects. Este es uno de los principios b&#xe1;sicos de MyBatis y la raz&#xf3;n por la que se ha puesto tanto esfuerzo en las consultas y el mapeo de resultados. El select statement es bastante simple para los casos simples. Por ejemplo:
        </p>

        
<pre class="prettyprint"><code>&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;
  SELECT * FROM PERSON WHERE ID = #{id}
&lt;/select&gt;</code></pre>

        
<p>Esta sentencia se llama &#x201c;selectPerson&#x201d;, recibe un par&#xe1;metro de tipo in (o Integer), y devuelve una HashMap usando los nombres de columna como clave y los valores del registro como valores.
        </p>

        
<p>
          Observa la notaci&#xf3;n utilizada para los par&#xe1;metros:
        </p>

        
<pre class="prettyprint"><code>#{id}</code></pre>

        
<p>Esto le indica a MyBatis que cree un par&#xe1;metro de PreparedStatement. Con JDBC, ese par&#xe1;metro ir&#xed;a identificado con una &#x201c;?&#x201d; en la select que se le pasa al PreparedStatement, algo as&#xed;:
        </p>

        
<pre class="prettyprint"><code>// C&#xf3;digo JDBC similar, NO MyBatis&#x2026;
String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);</code></pre>

        
<p>JDBC requiere mucho m&#xe1;s c&#xf3;digo para extraer los resultados y mapearlos a una instancia de un objetos, que es precisamente lo que MyBatis evita que tengas que hacer. Aun queda mucho por conocer sobre los par&#xe1;metros y el mapeo de resultados. Todos sus detalles merecen su propio cap&#xed;tulo, y ser&#xe1;n tratados m&#xe1;s adelante.
        </p>

        
<p>El select statement tiene m&#xe1;s atributos que te permiten configurar como debe comportarse cada select statement.</p>

        
<pre class="prettyprint"><code>&lt;select
  id=&quot;selectPerson&quot;
  parameterType=&quot;int&quot;
  parameterMap=&quot;deprecated&quot;
  resultType=&quot;hashmap&quot;
  resultMap=&quot;personResultMap&quot;
  flushCache=&quot;false&quot;
  useCache=&quot;true&quot;
  timeout=&quot;10&quot;
  fetchSize=&quot;256&quot;
  statementType=&quot;PREPARED&quot;
  resultSetType=&quot;FORWARD_ONLY&quot;&gt;</code></pre>

        
<table class="table table-striped"><caption>Atributos de Select</caption>
          
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td><code>id</code></td>
              
<td>Un identificador &#xfa;nico dentro del namespace que se utiliza para identificar el statement.</td>
            </tr>
            
<tr class="a">
              
<td><code>parameterType</code></td>
              
<td>El nombre completamente cualificado de la clase o el alias del par&#xe1;metro que se pasar&#xe1; al statement.
              Este atributo es opcional porque MyBatis puede calcular el TypeHandler a utlizar a partir del parametro actual usado en la invocaci&#xf3;n al statement.
              Por defecto: no informado.</td>
            </tr>
            
<tr class="b">
              
<td>
                <del>parameterMap</del>
              </td>
              
<td>
                <del>Este es un atributo obsoleto que permite referenciar a un elemento parameterMap externo. Se recomienda utilizar mapeos en l&#xed;nea (in-line) y el atributo parameterType.
                </del>
              </td>
            </tr>
            
<tr class="a">
              
<td><code>resultType</code></td>
              
<td>El nombre completamente cualificado o el alias del tipo de retorno de este statement. Ten en cuenta que en el caso de las colecciones el par&#xe1;metro debe ser el tipo contenido en la colecci&#xf3;n, no el propio tipo de la colecci&#xf3;n. Puedes utilizar resultType o resultMap, pero no ambos.
              </td>
          </tr>
            
<tr class="b">
              
<td><code>resultMap</code></td>
              
<td>Una referencia una un resultMap externo. Los resultMaps son la caracter&#xed;stica m&#xe1;s potente de MyBatis, con un conocimiento detallado de los mismos, se pueden resolver muchos casos complejos de mapeos. Puedes utilizar resultMap O resultType, pero no ambos.
              </td>
            </tr>
            
<tr class="a">
              
<td><code>flushCache</code></td>
              
<td>Informar esta propiedad a true har&#xe1; que la cache local y la de segundo nivel se vac&#xed;en cada vez que se llame a este statement. Por defecto es false para select statements.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>useCache</code></td>
              
<td>Informar esta propiedad a true har&#xe1; que los resultados de la ejecuci&#xf3;n de este statement se cacheen en la cach&#xe9; de segundo nivel. Por defecto es true para las select statements.
              </td>
            </tr>
            
<tr class="a">
              
<td><code>timeout</code></td>
              
<td>Establece el n&#xfa;mero de segundos que el driver esperar&#xe1; a que la base de datos le devuelva una respuesta antes de lanzar una excepci&#xf3;n. Por defecto: no informado (depende del driver de base de datos).
              </td>
            </tr>
            
<tr class="b">
              
<td><code>fetchSize</code></td>
              
<td>Este es un atributo que &#x201c;sugiere&#x201d; al driver que devuelva los resultados en bloques de filas en el n&#xfa;mero indicado por el par&#xe1;metro. Por defecto: no informado (depende del driver de base de datos).
              </td>
            </tr>
            
<tr class="a">
              
<td><code>statementType</code></td>
              
<td>Puede valer STATEMENT, PREPARED o CALLABLE. Hace que MyBatis use Statement, PreparedStatement o CallableStatement respectivamente.  Por defecto: PREPARED.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>resultSetType</code></td>
              
<td>Puede valer FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE|DEFAULT(same as unset).  Por defecto: no informado (depende del driver de base de datos).
              </td>
            </tr>
            
<tr class="a">
              
<td><code>databaseId</code></td>
              
<td>Si hay un DatabaseIdProvider configurado. MyBatis cargar&#xe1; todos los statements sin el atributo <code>databaseId</code>
              o aquellos con un <code>databaseId</code> que coincide con el actual. Si se encuentra un statement con y sin
              <code>databaseId</code> el &#xfa;ltimo se descartar&#xe1;.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>resultOrdered</code></td>
              
<td>De aplicaci&#xf3;n exclusiva para select anidadas. Si es true, se asume que los resultados anidados est&#xe1;n
                agrupados de forma que cuando se lee un nuevo resultado principal nuevo, no habr&#xe1; m&#xe1;s referencias
                a resultados principales anteriores. De esta forma los resultados anidados se rellenar&#xe1;n de
                una manera mucho &#xe1;s eficiente en t&#xe9;rminos de memoria. Defecto:
                <code>false</code>.
              </td>
            </tr>
            
<tr class="a">
              
<td><code>resultSets</code></td>
              
<td>This is only applicable for multiple result sets. It lists the result sets that will
                be returned by the statement and gives a name to each one. Names are separated by commas.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>affectData</code></td>
              
<td>Set this to true when writing a INSERT, UPDATE or DELETE statement that returns data so that the transaction is controlled properly. Also see <a href="./java-api.html#transaction-control-methods">Transaction Control Method</a>. Default: <code>false</code> (since 3.5.12)
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <a id="insert_update_and_delete"></a><section id="insert_update_and_delete"><a id="insert.2C_update_and_delete"></a>
<h2>insert, update and delete</h2>
        
<p>Los insert, update y delete statements son muy similares en su implementaci&#xf3;n:</p>

        
<pre class="prettyprint"><code>&lt;insert
  id=&quot;insertAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  keyProperty=&quot;&quot;
  keyColumn=&quot;&quot;
  useGeneratedKeys=&quot;&quot;
  timeout=&quot;20&quot;&gt;

&lt;update
  id=&quot;updateAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;

&lt;delete
  id=&quot;deleteAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;</code></pre>

        
<table class="table table-striped"><caption>Insert, Update and Delete Attributes</caption>
          
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td><code>id</code></td>
              
<td>Un identificador &#xfa;nico dentro del namespace que se utiliza para identificar el statement.</td>
            </tr>
            
<tr class="a">
              
<td><code>parameterType</code></td>
              
<td>El nombre completamente cualificado de la clase o el alias del par&#xe1;metro que se pasar&#xe1; al statement.
              Este atributo es opcional porque MyBatis puede calcular el TypeHandler a utlizar a partir del parametro actual usado en la invocaci&#xf3;n al statement.
              Por defecto: no informado.</td>
            </tr>
            
<tr class="b">
              
<td>
                <del><code>parameterMap</code></del>
              </td>
              
<td>
                <del>M&#xe9;todo deprecado de referirse a un parameterMap externo. Usa mapeos inline y el atributo paramterType.</del>
              </td>
            </tr>
            
<tr class="a">
              
<td><code>flushCache</code></td>
              
<td>Informar esta propiedad a true har&#xe1; que la cach&#xe9; se vac&#xed;e cada vez que se llame a este statement. Por defecto es false para select statements.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>timeout</code></td>
              
<td>Establece el n&#xfa;mero m&#xe1;ximo de segundos que el driver esperar&#xe1; a que la base de datos le devuelva una respuesta antes de lanzar una excepci&#xf3;n. Por defecto: no informado (depende del driver de base de datos).</td>
            </tr>
            
<tr class="a">
              
<td><code>statementType</code></td>
              
<td>Puede valer STATEMENT, PREPARED o CALLABLE. Hace que MyBatis use Statement, PreparedStatement o CallableStatement respectivamente.  Por defecto: PREPARED.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>useGeneratedKeys</code></td>
              
<td>(solo en insert y update) Indica a MyBatis que utilice el m&#xe9;todo getGeneratedKeys de JDBC para recuperar las claves autogeneras autom&#xe1;ticamente por la base de datos. (ej. campos autoincrementales en SGBD como MySQL o SQL Server).  Por defecto:  false
              </td>
            </tr>
            
<tr class="a">
              
<td><code>keyProperty</code></td>
              
<td>(solo en insert y update) Indica la propiedad a la que MyBatis debe asignar la clave autogenerada devuelva por getGeneratedKeys o por un elemento hijo de tipo selectKey. Por defecto: no informado. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>keyColumn</code></td>
              
<td>(solo en insert y update) Indica el nombre de la columna en tabla con clave generada. Solo se requiere en algunas bases de datos (como PostgreSQL) donde la
              columna clave no es la primera de la tabla. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="a">
              
<td><code>databaseId</code></td>
              
<td>Si hay un DatabaseIdProvider configurado. MyBatis cargar&#xe1; todos los statements sin el atributo <code>databaseId</code>
              o aquellos con un <code>databaseId</code> que coincide con el actual. Si se encuentra un statement con y sin
              <code>databaseId</code> el &#xfa;ltimo se descartar&#xe1;.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>A continuaci&#xf3;n se muestran unos ejemplos de insert, update y delete.</p>

        
<pre class="prettyprint"><code>&lt;insert id=&quot;insertAuthor&quot;&gt;
  insert into Author (id,username,password,email,bio)
  values (#{id},#{username},#{password},#{email},#{bio})
&lt;/insert&gt;

&lt;update id=&quot;updateAuthor&quot;&gt;
  update Author set
    username = #{username},
    password = #{password},
    email = #{email},
    bio = #{bio}
  where id = #{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteAuthor&quot;&gt;
  delete from Author where id = #{id}
&lt;/delete&gt;</code></pre>

        
<p>Tal y como se ha indicado, insert es algo m&#xe1;s complejo dado que dispone de algunos atributos extra para gestionar la generaci&#xf3;n de claves de varias formas distintas.
        </p>

        
<p>
          Primeramente, si tu base de datos soporta la auto-generaci&#xf3;n de claves (ej. MySQL y SQL Server), entonces puedes simplemente informar el atributo useGeneratedKeys=&#x201d;true&#x201d; e informar tambi&#xe9;n en keyProperty el nombre del la propiedad donde guardar el valor y ya has terminado.
Por ejemplo, si la columna id de la tabla Author del ejemplo siguiente fuera autogenerada el insert statement se escribir&#xed;a de la siguiente forma:
        </p>

        
<pre class="prettyprint"><code>&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;
    keyProperty=&quot;id&quot;&gt;
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
&lt;/insert&gt;</code></pre>

        
<p>
          If your database also supports multi-row insert, you can pass a list or an array of <code>Author</code>s and retrieve the auto-generated keys.
        </p>

        
<pre class="prettyprint"><code>&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;
    keyProperty=&quot;id&quot;&gt;
  insert into Author (username, password, email, bio) values
  &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;
    (#{item.username}, #{item.password}, #{item.email}, #{item.bio})
  &lt;/foreach&gt;
&lt;/insert&gt;</code></pre>

        
<p>MyBatis puede tratar las claves autogeneradas de otra forma para el caso de las bases de datos que no soportan columnas autogeneradas, o porque su driver JDBC no haya incluido aun dicho soporte.
        </p>

        
<p>A continuaci&#xf3;n se muestra un ejemplo muy simple que genera un id aleatorio (algo que posiblemente nunca har&#xe1;s pero que demuestra la flexibilidad de MyBatis y c&#xf3;mo MyBatis ignora la forma en la que se consigue la clave):
        </p>
        
<pre class="prettyprint"><code>&lt;insert id=&quot;insertAuthor&quot;&gt;
  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1
  &lt;/selectKey&gt;
  insert into Author
    (id, username, password, email,bio, favourite_section)
  values
    (#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR})
&lt;/insert&gt;</code></pre>
        
<p>
          En el ejemplo anterior, el selectKey statement se ejecuta primero, la propiedad id de Author se informar&#xe1; y posteriormente se invocar&#xe1; al insert statement. Esto proporciona un comportamiento similar a la generaci&#xf3;n de claves en base de datos sin complicar el c&#xf3;digo Java.
        </p>
        
<p>El elemento selectKey tiene el siguiente aspecto:</p>
        
<pre class="prettyprint"><code>&lt;selectKey
  keyProperty=&quot;id&quot;
  resultType=&quot;int&quot;
  order=&quot;BEFORE&quot;
  statementType=&quot;PREPARED&quot;&gt;</code></pre>

        
<table class="table table-striped"><caption>selectKey Attributes</caption>
          
          <thead>
            
<tr class="a">
              
<th>Attribute</th>
              
<th>Description</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td><code>keyProperty</code></td>
              
<td>La propiedad destino con la que debe informarse el resultado del selectKey statement. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="a">
              
<td><code>keyColumn</code></td>
              
<td>Los nombres de columnas en el ResultSet que corresponden con las propiedades. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>resultType</code></td>
              
<td>El tipo de retorno. MyBatis puede adivinarlo pero no est&#xe1; de m&#xe1;s a&#xf1;adirlo para asegurarse. MyBatis permite usar cualquier tipo simple, incluyendo Strings.
              </td>
            </tr>
            
<tr class="a">
              
<td><code>order</code></td>
              
<td>Puede contener BEFORE o AFTER. Si se informa a BEFORE, entonces la obtenci&#xf3;n de la clave se realizar&#xe1; primero, se informar&#xe1; el campo indicado en keyProperty y se ejecutar&#xe1; la insert. Si se informa a AFTER se ejecuta primero la insert y despu&#xe9;s la selectKey &#x2013; Esto es habitual en bases de datos como Oracle que soportan llamadas embebidas a secuencias dentro de una sentencia insert.
              </td>
            </tr>
            
<tr class="b">
              
<td><code>statementType</code></td>
              
<td>Al igual que antes, MyBatis soporta sentencias de tipo STATEMENT, PREPARED and CALLABLE que corresponden Statement, PreparedStatement y CallableStatement respectivamente.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>
          As an irregular case, some databases allow INSERT, UPDATE or DELETE statement to return result set (e.g. <code>RETURNING</code> clause of PostgreSQL and MariaDB or <code>OUTPUT</code> clause of MS SQL Server). This type of statement must be written as <code>&lt;select&gt;</code> to map the returned data.
        </p>

        
<pre class="prettyprint"><code>&lt;select id=&quot;insertAndGetAuthor&quot; resultType=&quot;domain.blog.Author&quot;
      affectData=&quot;true&quot; flushCache=&quot;true&quot;&gt;
  insert into Author (username, password, email, bio)
  values (#{username}, #{password}, #{email}, #{bio})
  returning id, username, password, email, bio
&lt;/select&gt;</code></pre>

      </section>

      <section><a id="sql"></a>
<h2>sql</h2>
        
<p>Este elemento se utiliza para definir un fragmento reusable de c&#xf3;digo SQL que puede ser incluido en otras sentencias. It can be statically (during load phase) parametrized. Different property values can
          vary in include instances. Por ejemplo:
        </p>

        
<pre class="prettyprint"><code>&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;</code></pre>

        
<p>Este fragmento de SQL puede ser incluido en otra sentencia, por ejemplo:
        </p>

        
<pre class="prettyprint"><code>&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;
  select
    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;,
    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt;
  from some_table t1
    cross join some_table t2
&lt;/select&gt;</code></pre>

        
<p>
          Property value can be also used in include refid attribute or property values inside include clause, for example:
        </p>

        
<pre class="prettyprint"><code>&lt;sql id=&quot;sometable&quot;&gt;
  ${prefix}Table
&lt;/sql&gt;

&lt;sql id=&quot;someinclude&quot;&gt;
  from
    &lt;include refid=&quot;${include_target}&quot;/&gt;
&lt;/sql&gt;

&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;
  select
    field1, field2, field3
  &lt;include refid=&quot;someinclude&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;
    &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt;
  &lt;/include&gt;
&lt;/select&gt;</code></pre>
      </section>

      <section><a id="Parameters"></a>
<h2>Parameters</h2>
        
<p>En todos los statements anteriores se han mostrado ejemplos de par&#xe1;metros simples. Los par&#xe1;metros son elementos muy potentes en MyBatis. En los casos simples, probablemente el 90% de los casos, no hay mucho que decir sobre ellos, por ejemplo:
        </p>

        
<pre class="prettyprint"><code>&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
  select id, username, password
  from users
  where id = #{id}
&lt;/select&gt;</code></pre>

        
<p>El ejemplo anterior muestra un mapeo muy simple de par&#xe1;metro con nombre. El atributo parameterType se ha informado a &#x201c;int&#x201d;, por lo tanto el nombre del par&#xe1;metro puede ser cualquiera. Los tipos primitivos y los tipos de datos simples como Integer o String no tienen propiedades relevantes y por tanto el par&#xe1;metro ser&#xe1; reemplazado por su valor. Sin embargo, si pasas un objeto complejo, entonces el comportamiento es distinto. Por ejemplo:
        </p>

        
<pre class="prettyprint"><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;
  insert into users (id, username, password)
  values (#{id}, #{username}, #{password})
&lt;/insert&gt;</code></pre>

        
<p>Si se pasa un objeto de tipo User como par&#xe1;metro en este statement, se buscar&#xe1;n en &#xe9;l las propiedades id, username y password  y sus valores se pasar&#xe1;n como par&#xe1;metros de un PreparedStatement.
        </p>

        
<p>Esta es una Buena forma de pasar par&#xe1;metros a statements. Pero los parameter maps (mapas de par&#xe1;metros) tienen otras muchas caracter&#xed;sticas.features of parameter maps.
        </p>

        
<p>Primeramente, es posible especificar un tipo de dato concreto.
        </p>

        
<pre class="prettyprint"><code>#{property,javaType=int,jdbcType=NUMERIC}</code></pre>

        
<p>Como en otros casos, el tipo de Java (javaType) puede casi siempre obtenerse del objeto recibido como par&#xe1;metro, salvo si el objeto es un HashMap. En ese caso debe indicarse el javaType para asegurar que se usa el TypeHandler correcto.
        </p>

        
<p>
          <span class="label important">NOTA</span> El tipo JDBC es obligatorio para todas las columnas que admiten null cuando se pasa un null como valor. Puedes investigar este tema por tu cuenta leyendo los JavaDocs del m&#xe9;todo PreparedStatement.setNull().
        </p>

        
<p>Si quieres customizar aun m&#xe1;s el tratamiento de tipos de datos, puedes indicar un TypeHandler espec&#xed;fico (o un alias), por ejemplo:
        </p>

        
<pre class="prettyprint"><code>#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}</code></pre>

        
<p>Comienza a parecer demasiado verboso, pero lo cierto es que rara vez necesitaras nada de esto.</p>

        
<p>Para los tipos num&#xe9;ricos hay un atributo numericScale que permite especificar cuantas posiciones decimales son relevantes.
        </p>

        
<pre class="prettyprint"><code>#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}</code></pre>

        
<p>Finalmente, el atributo mode te permite especificar par&#xe1;metros IN, OUT o INOUT. Si un par&#xe1;metro es OUT o INOUT, el valor actual de las propiedades del objeto pasado como par&#xe1;metro ser&#xe1; modificado. Si el mode=OUT (o INOUT) y el jdbcType=CURSOR (ej. Oracle REFCURSOR), debes especificar un resultMap para mapear el RestultSet al tipo del par&#xe1;metro. Ten en cuenta que el atributo javaType es opcional en este caso, dado que se establecer&#xe1; autom&#xe1;ticamente al valor ResultSet en caso de no haberse especificado si el jdbcType es CURSOR.
        </p>

        
<pre class="prettyprint"><code>#{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap}</code></pre>

        
<p>MyBatis tambi&#xe9;n soporta tipos de datos avanzados como los structs, pero en este caso debes indicar in el statement el jdbcTypeName en la declaraci&#xf3;n del par&#xe1;metro de tipo OUT.
        </p>

        
<pre class="prettyprint"><code>#{middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap}</code></pre>

        
<p>A pesar de estas potentes opciones, la mayor&#xed;a de las veces simplemente debes especificar el nombre de la propiedad y MyBatis adivinar&#xe1; lo dem&#xe1;s. A lo sumo, deber&#xe1;s especificar los jdbcTypes para las columnas que admiten nulos.
        </p>

        
<pre class="prettyprint"><code>#{firstName}
#{middleInitial,jdbcType=VARCHAR}
#{lastName}</code></pre>

        <section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2009–2024
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>
