<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultResultSetHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.executor.resultset</a> &gt; <span class="el_source">DefaultResultSetHandler.java</span></div><h1>DefaultResultSetHandler.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2009-2024 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.executor.resultset;

import java.lang.reflect.Constructor;
import java.lang.reflect.Parameter;
import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import org.apache.ibatis.annotations.AutomapConstructor;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.binding.MapperMethod.ParamMap;
import org.apache.ibatis.cache.CacheKey;
import org.apache.ibatis.cursor.Cursor;
import org.apache.ibatis.cursor.defaults.DefaultCursor;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.ExecutorException;
import org.apache.ibatis.executor.loader.ResultLoader;
import org.apache.ibatis.executor.loader.ResultLoaderMap;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.executor.result.DefaultResultContext;
import org.apache.ibatis.executor.result.DefaultResultHandler;
import org.apache.ibatis.executor.result.ResultMapException;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.Discriminator;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.mapping.ParameterMode;
import org.apache.ibatis.mapping.ResultMap;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.reflection.MetaClass;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.ReflectorFactory;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.session.AutoMappingBehavior;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ResultContext;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.TypeHandlerRegistry;
import org.apache.ibatis.util.MapUtil;

/**
 * @author Clinton Begin
 * @author Eduardo Macarron
 * @author Iwao AVE!
 * @author Kazuki Shimizu
 */
public class DefaultResultSetHandler implements ResultSetHandler {

<span class="fc" id="L79">  private static final Object DEFERRED = new Object();</span>

  private final Executor executor;
  private final Configuration configuration;
  private final MappedStatement mappedStatement;
  private final RowBounds rowBounds;
  private final ParameterHandler parameterHandler;
  private final ResultHandler&lt;?&gt; resultHandler;
  private final BoundSql boundSql;
  private final TypeHandlerRegistry typeHandlerRegistry;
  private final ObjectFactory objectFactory;
  private final ReflectorFactory reflectorFactory;

  // nested resultmaps
<span class="fc" id="L93">  private final Map&lt;CacheKey, Object&gt; nestedResultObjects = new HashMap&lt;&gt;();</span>
<span class="fc" id="L94">  private final Map&lt;String, Object&gt; ancestorObjects = new HashMap&lt;&gt;();</span>
  private Object previousRowValue;

  // multiple resultsets
<span class="fc" id="L98">  private final Map&lt;String, ResultMapping&gt; nextResultMaps = new HashMap&lt;&gt;();</span>
<span class="fc" id="L99">  private final Map&lt;CacheKey, List&lt;PendingRelation&gt;&gt; pendingRelations = new HashMap&lt;&gt;();</span>

  // Cached Automappings
<span class="fc" id="L102">  private final Map&lt;String, List&lt;UnMappedColumnAutoMapping&gt;&gt; autoMappingsCache = new HashMap&lt;&gt;();</span>
<span class="fc" id="L103">  private final Map&lt;String, List&lt;String&gt;&gt; constructorAutoMappingColumns = new HashMap&lt;&gt;();</span>

  // temporary marking flag that indicate using constructor mapping (use field to reduce memory usage)
  private boolean useConstructorMappings;

  private static class PendingRelation {
    public MetaObject metaObject;
    public ResultMapping propertyMapping;
  }

  private static class UnMappedColumnAutoMapping {
    private final String column;
    private final String property;
    private final TypeHandler&lt;?&gt; typeHandler;
    private final boolean primitive;

<span class="fc" id="L119">    public UnMappedColumnAutoMapping(String column, String property, TypeHandler&lt;?&gt; typeHandler, boolean primitive) {</span>
<span class="fc" id="L120">      this.column = column;</span>
<span class="fc" id="L121">      this.property = property;</span>
<span class="fc" id="L122">      this.typeHandler = typeHandler;</span>
<span class="fc" id="L123">      this.primitive = primitive;</span>
<span class="fc" id="L124">    }</span>
  }

  public DefaultResultSetHandler(Executor executor, MappedStatement mappedStatement, ParameterHandler parameterHandler,
<span class="fc" id="L128">      ResultHandler&lt;?&gt; resultHandler, BoundSql boundSql, RowBounds rowBounds) {</span>
<span class="fc" id="L129">    this.executor = executor;</span>
<span class="fc" id="L130">    this.configuration = mappedStatement.getConfiguration();</span>
<span class="fc" id="L131">    this.mappedStatement = mappedStatement;</span>
<span class="fc" id="L132">    this.rowBounds = rowBounds;</span>
<span class="fc" id="L133">    this.parameterHandler = parameterHandler;</span>
<span class="fc" id="L134">    this.boundSql = boundSql;</span>
<span class="fc" id="L135">    this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span>
<span class="fc" id="L136">    this.objectFactory = configuration.getObjectFactory();</span>
<span class="fc" id="L137">    this.reflectorFactory = configuration.getReflectorFactory();</span>
<span class="fc" id="L138">    this.resultHandler = resultHandler;</span>
<span class="fc" id="L139">  }</span>

  //
  // HANDLE OUTPUT PARAMETER
  //

  @Override
  public void handleOutputParameters(CallableStatement cs) throws SQLException {
<span class="fc" id="L147">    final Object parameterObject = parameterHandler.getParameterObject();</span>
<span class="fc" id="L148">    final MetaObject metaParam = configuration.newMetaObject(parameterObject);</span>
<span class="fc" id="L149">    final List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">    for (int i = 0; i &lt; parameterMappings.size(); i++) {</span>
<span class="fc" id="L151">      final ParameterMapping parameterMapping = parameterMappings.get(i);</span>
<span class="pc bpc" id="L152" title="1 of 4 branches missed.">      if (parameterMapping.getMode() == ParameterMode.OUT || parameterMapping.getMode() == ParameterMode.INOUT) {</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if (ResultSet.class.equals(parameterMapping.getJavaType())) {</span>
<span class="nc" id="L154">          handleRefCursorOutputParameter((ResultSet) cs.getObject(i + 1), parameterMapping, metaParam);</span>
        } else {
<span class="fc" id="L156">          final TypeHandler&lt;?&gt; typeHandler = parameterMapping.getTypeHandler();</span>
<span class="fc" id="L157">          metaParam.setValue(parameterMapping.getProperty(), typeHandler.getResult(cs, i + 1));</span>
        }
      }
    }
<span class="fc" id="L161">  }</span>

  private void handleRefCursorOutputParameter(ResultSet rs, ParameterMapping parameterMapping, MetaObject metaParam)
      throws SQLException {
<span class="nc bnc" id="L165" title="All 2 branches missed.">    if (rs == null) {</span>
<span class="nc" id="L166">      return;</span>
    }
    try {
<span class="nc" id="L169">      final String resultMapId = parameterMapping.getResultMapId();</span>
<span class="nc" id="L170">      final ResultMap resultMap = configuration.getResultMap(resultMapId);</span>
<span class="nc" id="L171">      final ResultSetWrapper rsw = new ResultSetWrapper(rs, configuration);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">      if (this.resultHandler == null) {</span>
<span class="nc" id="L173">        final DefaultResultHandler resultHandler = new DefaultResultHandler(objectFactory);</span>
<span class="nc" id="L174">        handleRowValues(rsw, resultMap, resultHandler, new RowBounds(), null);</span>
<span class="nc" id="L175">        metaParam.setValue(parameterMapping.getProperty(), resultHandler.getResultList());</span>
<span class="nc" id="L176">      } else {</span>
<span class="nc" id="L177">        handleRowValues(rsw, resultMap, resultHandler, new RowBounds(), null);</span>
      }
    } finally {
      // issue #228 (close resultsets)
<span class="nc" id="L181">      closeResultSet(rs);</span>
    }
<span class="nc" id="L183">  }</span>

  //
  // HANDLE RESULT SETS
  //
  @Override
  public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
<span class="fc" id="L190">    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());</span>

<span class="fc" id="L192">    final List&lt;Object&gt; multipleResults = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L194">    int resultSetCount = 0;</span>
<span class="fc" id="L195">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span>

<span class="fc" id="L197">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span>
<span class="fc" id="L198">    int resultMapCount = resultMaps.size();</span>
<span class="fc" id="L199">    validateResultMapsCount(rsw, resultMapCount);</span>
<span class="fc bfc" id="L200" title="All 4 branches covered.">    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {</span>
<span class="fc" id="L201">      ResultMap resultMap = resultMaps.get(resultSetCount);</span>
<span class="fc" id="L202">      handleResultSet(rsw, resultMap, multipleResults, null);</span>
<span class="fc" id="L203">      rsw = getNextResultSet(stmt);</span>
<span class="fc" id="L204">      cleanUpAfterHandlingResultSet();</span>
<span class="fc" id="L205">      resultSetCount++;</span>
<span class="fc" id="L206">    }</span>

<span class="fc" id="L208">    String[] resultSets = mappedStatement.getResultSets();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    if (resultSets != null) {</span>
<span class="pc bpc" id="L210" title="1 of 4 branches missed.">      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {</span>
<span class="fc" id="L211">        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (parentMapping != null) {</span>
<span class="fc" id="L213">          String nestedResultMapId = parentMapping.getNestedResultMapId();</span>
<span class="fc" id="L214">          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span>
<span class="fc" id="L215">          handleResultSet(rsw, resultMap, null, parentMapping);</span>
        }
<span class="fc" id="L217">        rsw = getNextResultSet(stmt);</span>
<span class="fc" id="L218">        cleanUpAfterHandlingResultSet();</span>
<span class="fc" id="L219">        resultSetCount++;</span>
<span class="fc" id="L220">      }</span>
    }

<span class="fc" id="L223">    return collapseSingleResultList(multipleResults);</span>
  }

  @Override
  public &lt;E&gt; Cursor&lt;E&gt; handleCursorResultSets(Statement stmt) throws SQLException {
<span class="fc" id="L228">    ErrorContext.instance().activity(&quot;handling cursor results&quot;).object(mappedStatement.getId());</span>

<span class="fc" id="L230">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span>

<span class="fc" id="L232">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span>

<span class="fc" id="L234">    int resultMapCount = resultMaps.size();</span>
<span class="fc" id="L235">    validateResultMapsCount(rsw, resultMapCount);</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">    if (resultMapCount != 1) {</span>
<span class="nc" id="L237">      throw new ExecutorException(&quot;Cursor results cannot be mapped to multiple resultMaps&quot;);</span>
    }

<span class="fc" id="L240">    ResultMap resultMap = resultMaps.get(0);</span>
<span class="fc" id="L241">    return new DefaultCursor&lt;&gt;(this, resultMap, rsw, rowBounds);</span>
  }

  private ResultSetWrapper getFirstResultSet(Statement stmt) throws SQLException {
<span class="fc" id="L245">    ResultSet rs = stmt.getResultSet();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">    while (rs == null) {</span>
      // move forward to get the first resultset in case the driver
      // doesn't return the resultset as the first result (HSQLDB)
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">      if (stmt.getMoreResults()) {</span>
<span class="nc" id="L250">        rs = stmt.getResultSet();</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">      } else if (stmt.getUpdateCount() == -1) {</span>
        // no more results. Must be no resultset
<span class="fc" id="L253">        break;</span>
      }
    }
<span class="fc bfc" id="L256" title="All 2 branches covered.">    return rs != null ? new ResultSetWrapper(rs, configuration) : null;</span>
  }

  private ResultSetWrapper getNextResultSet(Statement stmt) {
    // Making this method tolerant of bad JDBC drivers
    try {
<span class="fc bfc" id="L262" title="All 2 branches covered.">      if (stmt.getConnection().getMetaData().supportsMultipleResultSets()) {</span>
        // Crazy Standard JDBC way of determining if there are more results
        // DO NOT try to 'improve' the condition even if IDE tells you to!
        // It's important that getUpdateCount() is called here.
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">        if (!(!stmt.getMoreResults() &amp;&amp; stmt.getUpdateCount() == -1)) {</span>
<span class="fc" id="L267">          ResultSet rs = stmt.getResultSet();</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">          if (rs == null) {</span>
<span class="nc" id="L269">            return getNextResultSet(stmt);</span>
          } else {
<span class="fc" id="L271">            return new ResultSetWrapper(rs, configuration);</span>
          }
        }
      }
<span class="nc" id="L275">    } catch (Exception e) {</span>
      // Intentionally ignored.
<span class="fc" id="L277">    }</span>
<span class="fc" id="L278">    return null;</span>
  }

  private void closeResultSet(ResultSet rs) {
    try {
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">      if (rs != null) {</span>
<span class="fc" id="L284">        rs.close();</span>
      }
<span class="nc" id="L286">    } catch (SQLException e) {</span>
      // ignore
<span class="fc" id="L288">    }</span>
<span class="fc" id="L289">  }</span>

  private void cleanUpAfterHandlingResultSet() {
<span class="fc" id="L292">    nestedResultObjects.clear();</span>
<span class="fc" id="L293">  }</span>

  private void validateResultMapsCount(ResultSetWrapper rsw, int resultMapCount) {
<span class="fc bfc" id="L296" title="All 4 branches covered.">    if (rsw != null &amp;&amp; resultMapCount &lt; 1) {</span>
<span class="fc" id="L297">      throw new ExecutorException(</span>
<span class="fc" id="L298">          &quot;A query was run and no Result Maps were found for the Mapped Statement '&quot; + mappedStatement.getId()</span>
              + &quot;'. 'resultType' or 'resultMap' must be specified when there is no corresponding method.&quot;);
    }
<span class="fc" id="L301">  }</span>

  private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults,
      ResultMapping parentMapping) throws SQLException {
    try {
<span class="fc bfc" id="L306" title="All 2 branches covered.">      if (parentMapping != null) {</span>
<span class="fc" id="L307">        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">      } else if (resultHandler == null) {</span>
<span class="fc" id="L309">        DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);</span>
<span class="fc" id="L310">        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</span>
<span class="fc" id="L311">        multipleResults.add(defaultResultHandler.getResultList());</span>
<span class="fc" id="L312">      } else {</span>
<span class="fc" id="L313">        handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span>
      }
    } finally {
      // issue #228 (close resultsets)
<span class="fc" id="L317">      closeResultSet(rsw.getResultSet());</span>
    }
<span class="fc" id="L319">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;Object&gt; collapseSingleResultList(List&lt;Object&gt; multipleResults) {
<span class="fc bfc" id="L323" title="All 2 branches covered.">    return multipleResults.size() == 1 ? (List&lt;Object&gt;) multipleResults.get(0) : multipleResults;</span>
  }

  //
  // HANDLE ROWS FOR SIMPLE RESULTMAP
  //

  public void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler,
      RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
<span class="fc bfc" id="L332" title="All 2 branches covered.">    if (resultMap.hasNestedResultMaps()) {</span>
<span class="fc" id="L333">      ensureNoRowBounds();</span>
<span class="fc" id="L334">      checkResultHandler();</span>
<span class="fc" id="L335">      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span>
    } else {
<span class="fc" id="L337">      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span>
    }
<span class="fc" id="L339">  }</span>

  private void ensureNoRowBounds() {
<span class="pc bpc" id="L342" title="3 of 4 branches missed.">    if (configuration.isSafeRowBoundsEnabled() &amp;&amp; rowBounds != null</span>
<span class="nc bnc" id="L343" title="All 4 branches missed.">        &amp;&amp; (rowBounds.getLimit() &lt; RowBounds.NO_ROW_LIMIT || rowBounds.getOffset() &gt; RowBounds.NO_ROW_OFFSET)) {</span>
<span class="nc" id="L344">      throw new ExecutorException(</span>
          &quot;Mapped Statements with nested result mappings cannot be safely constrained by RowBounds. &quot;
              + &quot;Use safeRowBoundsEnabled=false setting to bypass this check.&quot;);
    }
<span class="fc" id="L348">  }</span>

  protected void checkResultHandler() {
<span class="pc bpc" id="L351" title="1 of 6 branches missed.">    if (resultHandler != null &amp;&amp; configuration.isSafeResultHandlerEnabled() &amp;&amp; !mappedStatement.isResultOrdered()) {</span>
<span class="fc" id="L352">      throw new ExecutorException(</span>
          &quot;Mapped Statements with nested result mappings cannot be safely used with a custom ResultHandler. &quot;
              + &quot;Use safeResultHandlerEnabled=false setting to bypass this check &quot;
              + &quot;or ensure your statement returns ordered data and set resultOrdered=true on it.&quot;);
    }
<span class="fc" id="L357">  }</span>

  private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap,
      ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
<span class="fc" id="L361">    DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;&gt;();</span>
<span class="fc" id="L362">    ResultSet resultSet = rsw.getResultSet();</span>
<span class="fc" id="L363">    skipRows(resultSet, rowBounds);</span>
<span class="pc bpc" id="L364" title="1 of 6 branches missed.">    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) {</span>
<span class="fc" id="L365">      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);</span>
<span class="fc" id="L366">      Object rowValue = getRowValue(rsw, discriminatedResultMap, null);</span>
<span class="fc" id="L367">      storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
<span class="fc" id="L368">    }</span>
<span class="fc" id="L369">  }</span>

  private void storeObject(ResultHandler&lt;?&gt; resultHandler, DefaultResultContext&lt;Object&gt; resultContext, Object rowValue,
      ResultMapping parentMapping, ResultSet rs) throws SQLException {
<span class="fc bfc" id="L373" title="All 2 branches covered.">    if (parentMapping != null) {</span>
<span class="fc" id="L374">      linkToParents(rs, parentMapping, rowValue);</span>
    } else {
<span class="fc" id="L376">      callResultHandler(resultHandler, resultContext, rowValue);</span>
    }
<span class="fc" id="L378">  }</span>

  @SuppressWarnings(&quot;unchecked&quot; /* because ResultHandler&lt;?&gt; is always ResultHandler&lt;Object&gt; */)
  private void callResultHandler(ResultHandler&lt;?&gt; resultHandler, DefaultResultContext&lt;Object&gt; resultContext,
      Object rowValue) {
<span class="fc" id="L383">    resultContext.nextResultObject(rowValue);</span>
<span class="fc" id="L384">    ((ResultHandler&lt;Object&gt;) resultHandler).handleResult(resultContext);</span>
<span class="fc" id="L385">  }</span>

  private boolean shouldProcessMoreRows(ResultContext&lt;?&gt; context, RowBounds rowBounds) {
<span class="fc bfc" id="L388" title="All 4 branches covered.">    return !context.isStopped() &amp;&amp; context.getResultCount() &lt; rowBounds.getLimit();</span>
  }

  private void skipRows(ResultSet rs, RowBounds rowBounds) throws SQLException {
<span class="fc bfc" id="L392" title="All 2 branches covered.">    if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">      if (rowBounds.getOffset() != RowBounds.NO_ROW_OFFSET) {</span>
<span class="fc" id="L394">        rs.absolute(rowBounds.getOffset());</span>
      }
    } else {
<span class="fc bfc" id="L397" title="All 2 branches covered.">      for (int i = 0; i &lt; rowBounds.getOffset(); i++) {</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (!rs.next()) {</span>
<span class="nc" id="L399">          break;</span>
        }
      }
    }
<span class="fc" id="L403">  }</span>

  //
  // GET VALUE FROM ROW FOR SIMPLE RESULT MAP
  //

  private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException {
<span class="fc" id="L410">    final ResultLoaderMap lazyLoader = new ResultLoaderMap();</span>
<span class="fc" id="L411">    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span>
<span class="fc bfc" id="L412" title="All 4 branches covered.">    if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {</span>
<span class="fc" id="L413">      final MetaObject metaObject = configuration.newMetaObject(rowValue);</span>
<span class="fc" id="L414">      boolean foundValues = this.useConstructorMappings;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">      if (shouldApplyAutomaticMappings(resultMap, false)) {</span>
<span class="fc bfc" id="L416" title="All 4 branches covered.">        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span>
      }
<span class="fc bfc" id="L418" title="All 4 branches covered.">      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span>
<span class="fc bfc" id="L419" title="All 4 branches covered.">      foundValues = lazyLoader.size() &gt; 0 || foundValues;</span>
<span class="fc bfc" id="L420" title="All 4 branches covered.">      rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;</span>
    }
<span class="fc" id="L422">    return rowValue;</span>
  }

  //
  // GET VALUE FROM ROW FOR NESTED RESULT MAP
  //

  private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, String columnPrefix,
      Object partialObject) throws SQLException {
<span class="fc" id="L431">    final String resultMapId = resultMap.getId();</span>
<span class="fc" id="L432">    Object rowValue = partialObject;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">    if (rowValue != null) {</span>
<span class="fc" id="L434">      final MetaObject metaObject = configuration.newMetaObject(rowValue);</span>
<span class="fc" id="L435">      putAncestor(rowValue, resultMapId);</span>
<span class="fc" id="L436">      applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);</span>
<span class="fc" id="L437">      ancestorObjects.remove(resultMapId);</span>
<span class="fc" id="L438">    } else {</span>
<span class="fc" id="L439">      final ResultLoaderMap lazyLoader = new ResultLoaderMap();</span>
<span class="fc" id="L440">      rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span>
<span class="fc bfc" id="L441" title="All 4 branches covered.">      if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {</span>
<span class="fc" id="L442">        final MetaObject metaObject = configuration.newMetaObject(rowValue);</span>
<span class="fc" id="L443">        boolean foundValues = this.useConstructorMappings;</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (shouldApplyAutomaticMappings(resultMap, true)) {</span>
<span class="pc bpc" id="L445" title="1 of 4 branches missed.">          foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span>
        }
<span class="fc bfc" id="L447" title="All 4 branches covered.">        foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span>
<span class="fc" id="L448">        putAncestor(rowValue, resultMapId);</span>
<span class="fc bfc" id="L449" title="All 4 branches covered.">        foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true)</span>
            || foundValues;
<span class="fc" id="L451">        ancestorObjects.remove(resultMapId);</span>
<span class="fc bfc" id="L452" title="All 4 branches covered.">        foundValues = lazyLoader.size() &gt; 0 || foundValues;</span>
<span class="fc bfc" id="L453" title="All 4 branches covered.">        rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;</span>
      }
<span class="fc bfc" id="L455" title="All 2 branches covered.">      if (combinedKey != CacheKey.NULL_CACHE_KEY) {</span>
<span class="fc" id="L456">        nestedResultObjects.put(combinedKey, rowValue);</span>
      }
    }
<span class="fc" id="L459">    return rowValue;</span>
  }

  private void putAncestor(Object resultObject, String resultMapId) {
<span class="fc" id="L463">    ancestorObjects.put(resultMapId, resultObject);</span>
<span class="fc" id="L464">  }</span>

  private boolean shouldApplyAutomaticMappings(ResultMap resultMap, boolean isNested) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">    if (resultMap.getAutoMapping() != null) {</span>
<span class="fc" id="L468">      return resultMap.getAutoMapping();</span>
    }
<span class="fc bfc" id="L470" title="All 2 branches covered.">    if (isNested) {</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">      return AutoMappingBehavior.FULL == configuration.getAutoMappingBehavior();</span>
    } else {
<span class="fc bfc" id="L473" title="All 2 branches covered.">      return AutoMappingBehavior.NONE != configuration.getAutoMappingBehavior();</span>
    }
  }

  //
  // PROPERTY MAPPINGS
  //

  private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject,
      ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {
<span class="fc" id="L483">    final Set&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span>
<span class="fc" id="L484">    boolean foundValues = false;</span>
<span class="fc" id="L485">    final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">    for (ResultMapping propertyMapping : propertyMappings) {</span>
<span class="fc" id="L487">      String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">      if (propertyMapping.getNestedResultMapId() != null) {</span>
        // the user added a column attribute to a nested result map, ignore it
<span class="fc" id="L490">        column = null;</span>
      }
<span class="fc bfc" id="L492" title="All 4 branches covered.">      if (propertyMapping.isCompositeResult()</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">          || column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">          || propertyMapping.getResultSet() != null) {</span>
<span class="fc" id="L495">        Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader,</span>
            columnPrefix);
        // issue #541 make property optional
<span class="fc" id="L498">        final String property = propertyMapping.getProperty();</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">        if (property == null) {</span>
<span class="fc" id="L500">          continue;</span>
        }
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (value == DEFERRED) {</span>
<span class="fc" id="L503">          foundValues = true;</span>
<span class="fc" id="L504">          continue;</span>
        }
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L507">          foundValues = true;</span>
        }
<span class="fc bfc" id="L509" title="All 2 branches covered.">        if (value != null</span>
<span class="pc bpc" id="L510" title="1 of 4 branches missed.">            || configuration.isCallSettersOnNulls() &amp;&amp; !metaObject.getSetterType(property).isPrimitive()) {</span>
          // gcode issue #377, call setter on nulls (value is not 'found')
<span class="fc" id="L512">          metaObject.setValue(property, value);</span>
        }
      }
<span class="fc" id="L515">    }</span>
<span class="fc" id="L516">    return foundValues;</span>
  }

  private Object getPropertyMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping,
      ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {
<span class="fc bfc" id="L521" title="All 2 branches covered.">    if (propertyMapping.getNestedQueryId() != null) {</span>
<span class="fc" id="L522">      return getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span>
    }
<span class="fc bfc" id="L524" title="All 2 branches covered.">    if (propertyMapping.getResultSet() != null) {</span>
<span class="fc" id="L525">      addPendingChildRelation(rs, metaResultObject, propertyMapping); // TODO is that OK?</span>
<span class="fc" id="L526">      return DEFERRED;</span>
    } else {
<span class="fc" id="L528">      final TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span>
<span class="fc" id="L529">      final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span>
<span class="fc" id="L530">      return typeHandler.getResult(rs, column);</span>
    }
  }

  private List&lt;UnMappedColumnAutoMapping&gt; createAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap,
      MetaObject metaObject, String columnPrefix) throws SQLException {
<span class="fc" id="L536">    final String mapKey = resultMap.getId() + &quot;:&quot; + columnPrefix;</span>
<span class="fc" id="L537">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = autoMappingsCache.get(mapKey);</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">    if (autoMapping == null) {</span>
<span class="fc" id="L539">      autoMapping = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L540">      final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span>
      // Remove the entry to release the memory
<span class="fc" id="L542">      List&lt;String&gt; mappedInConstructorAutoMapping = constructorAutoMappingColumns.remove(mapKey);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">      if (mappedInConstructorAutoMapping != null) {</span>
<span class="fc" id="L544">        unmappedColumnNames.removeAll(mappedInConstructorAutoMapping);</span>
      }
<span class="fc bfc" id="L546" title="All 2 branches covered.">      for (String columnName : unmappedColumnNames) {</span>
<span class="fc" id="L547">        String propertyName = columnName;</span>
<span class="pc bpc" id="L548" title="1 of 4 branches missed.">        if (columnPrefix != null &amp;&amp; !columnPrefix.isEmpty()) {</span>
          // When columnPrefix is specified,
          // ignore columns without the prefix.
<span class="fc bfc" id="L551" title="All 2 branches covered.">          if (!columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {</span>
<span class="fc" id="L552">            continue;</span>
          }
<span class="fc" id="L554">          propertyName = columnName.substring(columnPrefix.length());</span>
        }
<span class="fc" id="L556">        final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span>
<span class="fc bfc" id="L557" title="All 4 branches covered.">        if (property != null &amp;&amp; metaObject.hasSetter(property)) {</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">          if (resultMap.getMappedProperties().contains(property)) {</span>
<span class="fc" id="L559">            continue;</span>
          }
<span class="fc" id="L561">          final Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">          if (typeHandlerRegistry.hasTypeHandler(propertyType, rsw.getJdbcType(columnName))) {</span>
<span class="fc" id="L563">            final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span>
<span class="fc" id="L564">            autoMapping</span>
<span class="fc" id="L565">                .add(new UnMappedColumnAutoMapping(columnName, property, typeHandler, propertyType.isPrimitive()));</span>
<span class="fc" id="L566">          } else {</span>
<span class="fc" id="L567">            configuration.getAutoMappingUnknownColumnBehavior().doAction(mappedStatement, columnName, property,</span>
                propertyType);
          }
<span class="fc" id="L570">        } else {</span>
<span class="fc" id="L571">          configuration.getAutoMappingUnknownColumnBehavior().doAction(mappedStatement, columnName,</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">              property != null ? property : propertyName, null);</span>
        }
<span class="fc" id="L574">      }</span>
<span class="fc" id="L575">      autoMappingsCache.put(mapKey, autoMapping);</span>
    }
<span class="fc" id="L577">    return autoMapping;</span>
  }

  private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject,
      String columnPrefix) throws SQLException {
<span class="fc" id="L582">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span>
<span class="fc" id="L583">    boolean foundValues = false;</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">    if (!autoMapping.isEmpty()) {</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">      for (UnMappedColumnAutoMapping mapping : autoMapping) {</span>
<span class="fc" id="L586">        final Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L588">          foundValues = true;</span>
        }
<span class="pc bpc" id="L590" title="1 of 6 branches missed.">        if (value != null || configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive) {</span>
          // gcode issue #377, call setter on nulls (value is not 'found')
<span class="fc" id="L592">          metaObject.setValue(mapping.property, value);</span>
        }
<span class="fc" id="L594">      }</span>
    }
<span class="fc" id="L596">    return foundValues;</span>
  }

  // MULTIPLE RESULT SETS

  private void linkToParents(ResultSet rs, ResultMapping parentMapping, Object rowValue) throws SQLException {
<span class="fc" id="L602">    CacheKey parentKey = createKeyForMultipleResults(rs, parentMapping, parentMapping.getColumn(),</span>
<span class="fc" id="L603">        parentMapping.getForeignColumn());</span>
<span class="fc" id="L604">    List&lt;PendingRelation&gt; parents = pendingRelations.get(parentKey);</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">    if (parents != null) {</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">      for (PendingRelation parent : parents) {</span>
<span class="pc bpc" id="L607" title="2 of 4 branches missed.">        if (parent != null &amp;&amp; rowValue != null) {</span>
<span class="fc" id="L608">          linkObjects(parent.metaObject, parent.propertyMapping, rowValue);</span>
        }
<span class="fc" id="L610">      }</span>
    }
<span class="fc" id="L612">  }</span>

  private void addPendingChildRelation(ResultSet rs, MetaObject metaResultObject, ResultMapping parentMapping)
      throws SQLException {
<span class="fc" id="L616">    CacheKey cacheKey = createKeyForMultipleResults(rs, parentMapping, parentMapping.getColumn(),</span>
<span class="fc" id="L617">        parentMapping.getColumn());</span>
<span class="fc" id="L618">    PendingRelation deferLoad = new PendingRelation();</span>
<span class="fc" id="L619">    deferLoad.metaObject = metaResultObject;</span>
<span class="fc" id="L620">    deferLoad.propertyMapping = parentMapping;</span>
<span class="fc" id="L621">    List&lt;PendingRelation&gt; relations = MapUtil.computeIfAbsent(pendingRelations, cacheKey, k -&gt; new ArrayList&lt;&gt;());</span>
    // issue #255
<span class="fc" id="L623">    relations.add(deferLoad);</span>
<span class="fc" id="L624">    ResultMapping previous = nextResultMaps.get(parentMapping.getResultSet());</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">    if (previous == null) {</span>
<span class="fc" id="L626">      nextResultMaps.put(parentMapping.getResultSet(), parentMapping);</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">    } else if (!previous.equals(parentMapping)) {</span>
<span class="nc" id="L628">      throw new ExecutorException(&quot;Two different properties are mapped to the same resultSet&quot;);</span>
    }
<span class="fc" id="L630">  }</span>

  private CacheKey createKeyForMultipleResults(ResultSet rs, ResultMapping resultMapping, String names, String columns)
      throws SQLException {
<span class="fc" id="L634">    CacheKey cacheKey = new CacheKey();</span>
<span class="fc" id="L635">    cacheKey.update(resultMapping);</span>
<span class="pc bpc" id="L636" title="1 of 4 branches missed.">    if (columns != null &amp;&amp; names != null) {</span>
<span class="fc" id="L637">      String[] columnsArray = columns.split(&quot;,&quot;);</span>
<span class="fc" id="L638">      String[] namesArray = names.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">      for (int i = 0; i &lt; columnsArray.length; i++) {</span>
<span class="fc" id="L640">        Object value = rs.getString(columnsArray[i]);</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L642">          cacheKey.update(namesArray[i]);</span>
<span class="fc" id="L643">          cacheKey.update(value);</span>
        }
      }
    }
<span class="fc" id="L647">    return cacheKey;</span>
  }

  //
  // INSTANTIATION &amp; CONSTRUCTOR MAPPING
  //

  private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader,
      String columnPrefix) throws SQLException {
<span class="fc" id="L656">    this.useConstructorMappings = false; // reset previous mapping result</span>
<span class="fc" id="L657">    final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L658">    final List&lt;Object&gt; constructorArgs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L659">    Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span>
<span class="fc bfc" id="L660" title="All 4 branches covered.">    if (resultObject != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {</span>
<span class="fc" id="L661">      final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">      for (ResultMapping propertyMapping : propertyMappings) {</span>
        // issue gcode #109 &amp;&amp; issue #149
<span class="fc bfc" id="L664" title="All 4 branches covered.">        if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) {</span>
<span class="fc" id="L665">          resultObject = configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration,</span>
              objectFactory, constructorArgTypes, constructorArgs);
<span class="fc" id="L667">          break;</span>
        }
<span class="fc" id="L669">      }</span>
    }
<span class="fc bfc" id="L671" title="All 4 branches covered.">    this.useConstructorMappings = resultObject != null &amp;&amp; !constructorArgTypes.isEmpty(); // set current mapping result</span>
<span class="fc" id="L672">    return resultObject;</span>
  }

  private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes,
      List&lt;Object&gt; constructorArgs, String columnPrefix) throws SQLException {
<span class="fc" id="L677">    final Class&lt;?&gt; resultType = resultMap.getType();</span>
<span class="fc" id="L678">    final MetaClass metaType = MetaClass.forClass(resultType, reflectorFactory);</span>
<span class="fc" id="L679">    final List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">    if (hasTypeHandlerForResultObject(rsw, resultType)) {</span>
<span class="fc" id="L681">      return createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span>
    }
<span class="fc bfc" id="L683" title="All 2 branches covered.">    if (!constructorMappings.isEmpty()) {</span>
<span class="fc" id="L684">      return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs,</span>
          columnPrefix);
<span class="fc bfc" id="L686" title="All 4 branches covered.">    } else if (resultType.isInterface() || metaType.hasDefaultConstructor()) {</span>
<span class="fc" id="L687">      return objectFactory.create(resultType);</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">    } else if (shouldApplyAutomaticMappings(resultMap, false)) {</span>
<span class="fc" id="L689">      return createByConstructorSignature(rsw, resultMap, columnPrefix, resultType, constructorArgTypes,</span>
          constructorArgs);
    }
<span class="nc" id="L692">    throw new ExecutorException(&quot;Do not know how to create an instance of &quot; + resultType);</span>
  }

  Object createParameterizedResultObject(ResultSetWrapper rsw, Class&lt;?&gt; resultType,
      List&lt;ResultMapping&gt; constructorMappings, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs,
      String columnPrefix) {
<span class="fc" id="L698">    boolean foundValues = false;</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">    for (ResultMapping constructorMapping : constructorMappings) {</span>
<span class="fc" id="L700">      final Class&lt;?&gt; parameterType = constructorMapping.getJavaType();</span>
<span class="fc" id="L701">      final String column = constructorMapping.getColumn();</span>
      final Object value;
      try {
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (constructorMapping.getNestedQueryId() != null) {</span>
<span class="fc" id="L705">          value = getNestedQueryConstructorValue(rsw.getResultSet(), constructorMapping, columnPrefix);</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        } else if (constructorMapping.getNestedResultMapId() != null) {</span>
<span class="fc" id="L707">          String constructorColumnPrefix = getColumnPrefix(columnPrefix, constructorMapping);</span>
<span class="fc" id="L708">          final ResultMap resultMap = resolveDiscriminatedResultMap(rsw.getResultSet(),</span>
<span class="fc" id="L709">              configuration.getResultMap(constructorMapping.getNestedResultMapId()), constructorColumnPrefix);</span>
<span class="fc" id="L710">          value = getRowValue(rsw, resultMap, constructorColumnPrefix);</span>
<span class="fc" id="L711">        } else {</span>
<span class="fc" id="L712">          final TypeHandler&lt;?&gt; typeHandler = constructorMapping.getTypeHandler();</span>
<span class="fc" id="L713">          value = typeHandler.getResult(rsw.getResultSet(), prependPrefix(column, columnPrefix));</span>
        }
<span class="fc" id="L715">      } catch (ResultMapException | SQLException e) {</span>
<span class="fc" id="L716">        throw new ExecutorException(&quot;Could not process result for mapping: &quot; + constructorMapping, e);</span>
<span class="fc" id="L717">      }</span>
<span class="fc" id="L718">      constructorArgTypes.add(parameterType);</span>
<span class="fc" id="L719">      constructorArgs.add(value);</span>
<span class="pc bpc" id="L720" title="1 of 4 branches missed.">      foundValues = value != null || foundValues;</span>
<span class="fc" id="L721">    }</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">    return foundValues ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;</span>
  }

  private Object createByConstructorSignature(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix,
      Class&lt;?&gt; resultType, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) throws SQLException {
<span class="fc" id="L727">    return applyConstructorAutomapping(rsw, resultMap, columnPrefix, resultType, constructorArgTypes, constructorArgs,</span>
<span class="pc" id="L728">        findConstructorForAutomapping(resultType, rsw).orElseThrow(() -&gt; new ExecutorException(</span>
<span class="nc" id="L729">            &quot;No constructor found in &quot; + resultType.getName() + &quot; matching &quot; + rsw.getClassNames())));</span>
  }

  private Optional&lt;Constructor&lt;?&gt;&gt; findConstructorForAutomapping(final Class&lt;?&gt; resultType, ResultSetWrapper rsw) {
<span class="fc" id="L733">    Constructor&lt;?&gt;[] constructors = resultType.getDeclaredConstructors();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">    if (constructors.length == 1) {</span>
<span class="fc" id="L735">      return Optional.of(constructors[0]);</span>
    }
<span class="fc" id="L737">    Optional&lt;Constructor&lt;?&gt;&gt; annotated = Arrays.stream(constructors)</span>
<span class="fc" id="L738">        .filter(x -&gt; x.isAnnotationPresent(AutomapConstructor.class)).reduce((x, y) -&gt; {</span>
<span class="fc" id="L739">          throw new ExecutorException(&quot;@AutomapConstructor should be used in only one constructor.&quot;);</span>
        });
<span class="fc bfc" id="L741" title="All 2 branches covered.">    if (annotated.isPresent()) {</span>
<span class="fc" id="L742">      return annotated;</span>
    }
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">    if (configuration.isArgNameBasedConstructorAutoMapping()) {</span>
      // Finding-best-match type implementation is possible,
      // but using @AutomapConstructor seems sufficient.
<span class="nc" id="L747">      throw new ExecutorException(MessageFormat.format(</span>
          &quot;'argNameBasedConstructorAutoMapping' is enabled and the class ''{0}'' has multiple constructors, so @AutomapConstructor must be added to one of the constructors.&quot;,
<span class="nc" id="L749">          resultType.getName()));</span>
    } else {
<span class="fc" id="L751">      return Arrays.stream(constructors).filter(x -&gt; findUsableConstructorByArgTypes(x, rsw.getJdbcTypes())).findAny();</span>
    }
  }

  private boolean findUsableConstructorByArgTypes(final Constructor&lt;?&gt; constructor, final List&lt;JdbcType&gt; jdbcTypes) {
<span class="fc" id="L756">    final Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">    if (parameterTypes.length != jdbcTypes.size()) {</span>
<span class="fc" id="L758">      return false;</span>
    }
<span class="fc bfc" id="L760" title="All 2 branches covered.">    for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">      if (!typeHandlerRegistry.hasTypeHandler(parameterTypes[i], jdbcTypes.get(i))) {</span>
<span class="nc" id="L762">        return false;</span>
      }
    }
<span class="fc" id="L765">    return true;</span>
  }

  private Object applyConstructorAutomapping(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix,
      Class&lt;?&gt; resultType, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, Constructor&lt;?&gt; constructor)
      throws SQLException {
<span class="fc" id="L771">    boolean foundValues = false;</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">    if (configuration.isArgNameBasedConstructorAutoMapping()) {</span>
<span class="fc" id="L773">      foundValues = applyArgNameBasedConstructorAutoMapping(rsw, resultMap, columnPrefix, constructorArgTypes,</span>
          constructorArgs, constructor, foundValues);
    } else {
<span class="fc" id="L776">      foundValues = applyColumnOrderBasedConstructorAutomapping(rsw, constructorArgTypes, constructorArgs, constructor,</span>
          foundValues);
    }
<span class="pc bpc" id="L779" title="1 of 4 branches missed.">    return foundValues || configuration.isReturnInstanceForEmptyRow()</span>
<span class="pc" id="L780">        ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;</span>
  }

  private boolean applyColumnOrderBasedConstructorAutomapping(ResultSetWrapper rsw, List&lt;Class&lt;?&gt;&gt; constructorArgTypes,
      List&lt;Object&gt; constructorArgs, Constructor&lt;?&gt; constructor, boolean foundValues) throws SQLException {
<span class="fc" id="L785">    Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();</span>

<span class="fc bfc" id="L787" title="All 2 branches covered.">    if (parameterTypes.length &gt; rsw.getClassNames().size()) {</span>
<span class="fc" id="L788">      throw new ExecutorException(MessageFormat.format(</span>
          &quot;Constructor auto-mapping of ''{0}'' failed. The constructor takes ''{1}'' arguments, but there are only ''{2}'' columns in the result set.&quot;,
<span class="fc" id="L790">          constructor, parameterTypes.length, rsw.getClassNames().size()));</span>
    }

<span class="fc bfc" id="L793" title="All 2 branches covered.">    for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="fc" id="L794">      Class&lt;?&gt; parameterType = parameterTypes[i];</span>
<span class="fc" id="L795">      String columnName = rsw.getColumnNames().get(i);</span>
<span class="fc" id="L796">      TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(parameterType, columnName);</span>
<span class="fc" id="L797">      Object value = typeHandler.getResult(rsw.getResultSet(), columnName);</span>
<span class="fc" id="L798">      constructorArgTypes.add(parameterType);</span>
<span class="fc" id="L799">      constructorArgs.add(value);</span>
<span class="pc bpc" id="L800" title="1 of 4 branches missed.">      foundValues = value != null || foundValues;</span>
    }
<span class="fc" id="L802">    return foundValues;</span>
  }

  private boolean applyArgNameBasedConstructorAutoMapping(ResultSetWrapper rsw, ResultMap resultMap,
      String columnPrefix, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, Constructor&lt;?&gt; constructor,
      boolean foundValues) throws SQLException {
<span class="fc" id="L808">    List&lt;String&gt; missingArgs = null;</span>
<span class="fc" id="L809">    Parameter[] params = constructor.getParameters();</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">    for (Parameter param : params) {</span>
<span class="fc" id="L811">      boolean columnNotFound = true;</span>
<span class="fc" id="L812">      Param paramAnno = param.getAnnotation(Param.class);</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">      String paramName = paramAnno == null ? param.getName() : paramAnno.value();</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">      for (String columnName : rsw.getColumnNames()) {</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (columnMatchesParam(columnName, paramName, columnPrefix)) {</span>
<span class="fc" id="L816">          Class&lt;?&gt; paramType = param.getType();</span>
<span class="fc" id="L817">          TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(paramType, columnName);</span>
<span class="fc" id="L818">          Object value = typeHandler.getResult(rsw.getResultSet(), columnName);</span>
<span class="fc" id="L819">          constructorArgTypes.add(paramType);</span>
<span class="fc" id="L820">          constructorArgs.add(value);</span>
<span class="fc" id="L821">          final String mapKey = resultMap.getId() + &quot;:&quot; + columnPrefix;</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">          if (!autoMappingsCache.containsKey(mapKey)) {</span>
<span class="fc" id="L823">            MapUtil.computeIfAbsent(constructorAutoMappingColumns, mapKey, k -&gt; new ArrayList&lt;&gt;()).add(columnName);</span>
          }
<span class="fc" id="L825">          columnNotFound = false;</span>
<span class="pc bpc" id="L826" title="1 of 4 branches missed.">          foundValues = value != null || foundValues;</span>
        }
<span class="fc" id="L828">      }</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">      if (columnNotFound) {</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        if (missingArgs == null) {</span>
<span class="fc" id="L831">          missingArgs = new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L833">        missingArgs.add(paramName);</span>
      }
    }
<span class="fc bfc" id="L836" title="All 4 branches covered.">    if (foundValues &amp;&amp; constructorArgs.size() &lt; params.length) {</span>
<span class="fc" id="L837">      throw new ExecutorException(MessageFormat.format(</span>
          &quot;Constructor auto-mapping of ''{1}'' failed &quot; + &quot;because ''{0}'' were not found in the result set; &quot;
              + &quot;Available columns are ''{2}'' and mapUnderscoreToCamelCase is ''{3}''.&quot;,
<span class="fc" id="L840">          missingArgs, constructor, rsw.getColumnNames(), configuration.isMapUnderscoreToCamelCase()));</span>
    }
<span class="fc" id="L842">    return foundValues;</span>
  }

  private boolean columnMatchesParam(String columnName, String paramName, String columnPrefix) {
<span class="fc bfc" id="L846" title="All 2 branches covered.">    if (columnPrefix != null) {</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">      if (!columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {</span>
<span class="fc" id="L848">        return false;</span>
      }
<span class="fc" id="L850">      columnName = columnName.substring(columnPrefix.length());</span>
    }
<span class="fc" id="L852">    return paramName</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        .equalsIgnoreCase(configuration.isMapUnderscoreToCamelCase() ? columnName.replace(&quot;_&quot;, &quot;&quot;) : columnName);</span>
  }

  private Object createPrimitiveResultObject(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)
      throws SQLException {
<span class="fc" id="L858">    final Class&lt;?&gt; resultType = resultMap.getType();</span>
    final String columnName;
<span class="fc bfc" id="L860" title="All 2 branches covered.">    if (!resultMap.getResultMappings().isEmpty()) {</span>
<span class="fc" id="L861">      final List&lt;ResultMapping&gt; resultMappingList = resultMap.getResultMappings();</span>
<span class="fc" id="L862">      final ResultMapping mapping = resultMappingList.get(0);</span>
<span class="fc" id="L863">      columnName = prependPrefix(mapping.getColumn(), columnPrefix);</span>
<span class="fc" id="L864">    } else {</span>
<span class="fc" id="L865">      columnName = rsw.getColumnNames().get(0);</span>
    }
<span class="fc" id="L867">    final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(resultType, columnName);</span>
<span class="fc" id="L868">    return typeHandler.getResult(rsw.getResultSet(), columnName);</span>
  }

  //
  // NESTED QUERY
  //

  private Object getNestedQueryConstructorValue(ResultSet rs, ResultMapping constructorMapping, String columnPrefix)
      throws SQLException {
<span class="fc" id="L877">    final String nestedQueryId = constructorMapping.getNestedQueryId();</span>
<span class="fc" id="L878">    final MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span>
<span class="fc" id="L879">    final Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span>
<span class="fc" id="L880">    final Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, constructorMapping,</span>
        nestedQueryParameterType, columnPrefix);
<span class="fc" id="L882">    Object value = null;</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">    if (nestedQueryParameterObject != null) {</span>
<span class="fc" id="L884">      final BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span>
<span class="fc" id="L885">      final CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT,</span>
          nestedBoundSql);
<span class="fc" id="L887">      final Class&lt;?&gt; targetType = constructorMapping.getJavaType();</span>
<span class="fc" id="L888">      final ResultLoader resultLoader = new ResultLoader(configuration, executor, nestedQuery,</span>
          nestedQueryParameterObject, targetType, key, nestedBoundSql);
<span class="fc" id="L890">      value = resultLoader.loadResult();</span>
    }
<span class="fc" id="L892">    return value;</span>
  }

  private Object getNestedQueryMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping,
      ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {
<span class="fc" id="L897">    final String nestedQueryId = propertyMapping.getNestedQueryId();</span>
<span class="fc" id="L898">    final String property = propertyMapping.getProperty();</span>
<span class="fc" id="L899">    final MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span>
<span class="fc" id="L900">    final Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span>
<span class="fc" id="L901">    final Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, propertyMapping,</span>
        nestedQueryParameterType, columnPrefix);
<span class="fc" id="L903">    Object value = null;</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">    if (nestedQueryParameterObject != null) {</span>
<span class="fc" id="L905">      final BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span>
<span class="fc" id="L906">      final CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT,</span>
          nestedBoundSql);
<span class="fc" id="L908">      final Class&lt;?&gt; targetType = propertyMapping.getJavaType();</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">      if (executor.isCached(nestedQuery, key)) {</span>
<span class="fc" id="L910">        executor.deferLoad(nestedQuery, metaResultObject, property, key, targetType);</span>
<span class="fc" id="L911">        value = DEFERRED;</span>
      } else {
<span class="fc" id="L913">        final ResultLoader resultLoader = new ResultLoader(configuration, executor, nestedQuery,</span>
            nestedQueryParameterObject, targetType, key, nestedBoundSql);
<span class="fc bfc" id="L915" title="All 2 branches covered.">        if (propertyMapping.isLazy()) {</span>
<span class="fc" id="L916">          lazyLoader.addLoader(property, metaResultObject, resultLoader);</span>
<span class="fc" id="L917">          value = DEFERRED;</span>
        } else {
<span class="fc" id="L919">          value = resultLoader.loadResult();</span>
        }
      }
    }
<span class="fc" id="L923">    return value;</span>
  }

  private Object prepareParameterForNestedQuery(ResultSet rs, ResultMapping resultMapping, Class&lt;?&gt; parameterType,
      String columnPrefix) throws SQLException {
<span class="fc bfc" id="L928" title="All 2 branches covered.">    if (resultMapping.isCompositeResult()) {</span>
<span class="fc" id="L929">      return prepareCompositeKeyParameter(rs, resultMapping, parameterType, columnPrefix);</span>
    }
<span class="fc" id="L931">    return prepareSimpleKeyParameter(rs, resultMapping, parameterType, columnPrefix);</span>
  }

  private Object prepareSimpleKeyParameter(ResultSet rs, ResultMapping resultMapping, Class&lt;?&gt; parameterType,
      String columnPrefix) throws SQLException {
    final TypeHandler&lt;?&gt; typeHandler;
<span class="fc bfc" id="L937" title="All 2 branches covered.">    if (typeHandlerRegistry.hasTypeHandler(parameterType)) {</span>
<span class="fc" id="L938">      typeHandler = typeHandlerRegistry.getTypeHandler(parameterType);</span>
    } else {
<span class="fc" id="L940">      typeHandler = typeHandlerRegistry.getUnknownTypeHandler();</span>
    }
<span class="fc" id="L942">    return typeHandler.getResult(rs, prependPrefix(resultMapping.getColumn(), columnPrefix));</span>
  }

  private Object prepareCompositeKeyParameter(ResultSet rs, ResultMapping resultMapping, Class&lt;?&gt; parameterType,
      String columnPrefix) throws SQLException {
<span class="fc" id="L947">    final Object parameterObject = instantiateParameterObject(parameterType);</span>
<span class="fc" id="L948">    final MetaObject metaObject = configuration.newMetaObject(parameterObject);</span>
<span class="fc" id="L949">    boolean foundValues = false;</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">    for (ResultMapping innerResultMapping : resultMapping.getComposites()) {</span>
<span class="fc" id="L951">      final Class&lt;?&gt; propType = metaObject.getSetterType(innerResultMapping.getProperty());</span>
<span class="fc" id="L952">      final TypeHandler&lt;?&gt; typeHandler = typeHandlerRegistry.getTypeHandler(propType);</span>
<span class="fc" id="L953">      final Object propValue = typeHandler.getResult(rs, prependPrefix(innerResultMapping.getColumn(), columnPrefix));</span>
      // issue #353 &amp; #560 do not execute nested query if key is null
<span class="fc bfc" id="L955" title="All 2 branches covered.">      if (propValue != null) {</span>
<span class="fc" id="L956">        metaObject.setValue(innerResultMapping.getProperty(), propValue);</span>
<span class="fc" id="L957">        foundValues = true;</span>
      }
<span class="fc" id="L959">    }</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">    return foundValues ? parameterObject : null;</span>
  }

  private Object instantiateParameterObject(Class&lt;?&gt; parameterType) {
<span class="fc bfc" id="L964" title="All 2 branches covered.">    if (parameterType == null) {</span>
<span class="fc" id="L965">      return new HashMap&lt;&gt;();</span>
    }
<span class="fc bfc" id="L967" title="All 2 branches covered.">    if (ParamMap.class.equals(parameterType)) {</span>
<span class="fc" id="L968">      return new HashMap&lt;&gt;(); // issue #649</span>
    } else {
<span class="fc" id="L970">      return objectFactory.create(parameterType);</span>
    }
  }

  //
  // DISCRIMINATOR
  //

  public ResultMap resolveDiscriminatedResultMap(ResultSet rs, ResultMap resultMap, String columnPrefix)
      throws SQLException {
<span class="fc" id="L980">    Set&lt;String&gt; pastDiscriminators = new HashSet&lt;&gt;();</span>
<span class="fc" id="L981">    Discriminator discriminator = resultMap.getDiscriminator();</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">    while (discriminator != null) {</span>
<span class="fc" id="L983">      final Object value = getDiscriminatorValue(rs, discriminator, columnPrefix);</span>
<span class="fc" id="L984">      final String discriminatedMapId = discriminator.getMapIdFor(String.valueOf(value));</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">      if (!configuration.hasResultMap(discriminatedMapId)) {</span>
<span class="fc" id="L986">        break;</span>
      }
<span class="fc" id="L988">      resultMap = configuration.getResultMap(discriminatedMapId);</span>
<span class="fc" id="L989">      Discriminator lastDiscriminator = discriminator;</span>
<span class="fc" id="L990">      discriminator = resultMap.getDiscriminator();</span>
<span class="pc bpc" id="L991" title="1 of 4 branches missed.">      if (discriminator == lastDiscriminator || !pastDiscriminators.add(discriminatedMapId)) {</span>
<span class="fc" id="L992">        break;</span>
      }
<span class="fc" id="L994">    }</span>
<span class="fc" id="L995">    return resultMap;</span>
  }

  private Object getDiscriminatorValue(ResultSet rs, Discriminator discriminator, String columnPrefix)
      throws SQLException {
<span class="fc" id="L1000">    final ResultMapping resultMapping = discriminator.getResultMapping();</span>
<span class="fc" id="L1001">    final TypeHandler&lt;?&gt; typeHandler = resultMapping.getTypeHandler();</span>
<span class="fc" id="L1002">    return typeHandler.getResult(rs, prependPrefix(resultMapping.getColumn(), columnPrefix));</span>
  }

  private String prependPrefix(String columnName, String prefix) {
<span class="pc bpc" id="L1006" title="2 of 8 branches missed.">    if (columnName == null || columnName.length() == 0 || prefix == null || prefix.length() == 0) {</span>
<span class="fc" id="L1007">      return columnName;</span>
    }
<span class="fc" id="L1009">    return prefix + columnName;</span>
  }

  //
  // HANDLE NESTED RESULT MAPS
  //

  private void handleRowValuesForNestedResultMap(ResultSetWrapper rsw, ResultMap resultMap,
      ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
<span class="fc" id="L1018">    final DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;&gt;();</span>
<span class="fc" id="L1019">    ResultSet resultSet = rsw.getResultSet();</span>
<span class="fc" id="L1020">    skipRows(resultSet, rowBounds);</span>
<span class="fc" id="L1021">    Object rowValue = previousRowValue;</span>
<span class="pc bpc" id="L1022" title="1 of 6 branches missed.">    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) {</span>
<span class="fc" id="L1023">      final ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);</span>
<span class="fc" id="L1024">      final CacheKey rowKey = createRowKey(discriminatedResultMap, rsw, null);</span>
<span class="fc" id="L1025">      Object partialObject = nestedResultObjects.get(rowKey);</span>
      // issue #577 &amp;&amp; #542
<span class="fc bfc" id="L1027" title="All 2 branches covered.">      if (mappedStatement.isResultOrdered()) {</span>
<span class="fc bfc" id="L1028" title="All 4 branches covered.">        if (partialObject == null &amp;&amp; rowValue != null) {</span>
<span class="fc" id="L1029">          nestedResultObjects.clear();</span>
<span class="fc" id="L1030">          storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
        }
<span class="fc" id="L1032">        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, null, partialObject);</span>
      } else {
<span class="fc" id="L1034">        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, null, partialObject);</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">        if (partialObject == null) {</span>
<span class="fc" id="L1036">          storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
        }
      }
<span class="fc" id="L1039">    }</span>
<span class="fc bfc" id="L1040" title="All 6 branches covered.">    if (rowValue != null &amp;&amp; mappedStatement.isResultOrdered() &amp;&amp; shouldProcessMoreRows(resultContext, rowBounds)) {</span>
<span class="fc" id="L1041">      storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
<span class="fc" id="L1042">      previousRowValue = null;</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">    } else if (rowValue != null) {</span>
<span class="fc" id="L1044">      previousRowValue = rowValue;</span>
    }
<span class="fc" id="L1046">  }</span>

  //
  // NESTED RESULT MAP (JOIN MAPPING)
  //

  private boolean applyNestedResultMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject,
      String parentPrefix, CacheKey parentRowKey, boolean newObject) {
<span class="fc" id="L1054">    boolean foundValues = false;</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">    for (ResultMapping resultMapping : resultMap.getPropertyResultMappings()) {</span>
<span class="fc" id="L1056">      final String nestedResultMapId = resultMapping.getNestedResultMapId();</span>
<span class="pc bpc" id="L1057" title="1 of 4 branches missed.">      if (nestedResultMapId != null &amp;&amp; resultMapping.getResultSet() == null) {</span>
        try {
<span class="fc" id="L1059">          final String columnPrefix = getColumnPrefix(parentPrefix, resultMapping);</span>
<span class="fc" id="L1060">          final ResultMap nestedResultMap = getNestedResultMap(rsw.getResultSet(), nestedResultMapId, columnPrefix);</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">          if (resultMapping.getColumnPrefix() == null) {</span>
            // try to fill circular reference only when columnPrefix
            // is not specified for the nested result map (issue #215)
<span class="fc" id="L1064">            Object ancestorObject = ancestorObjects.get(nestedResultMapId);</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">            if (ancestorObject != null) {</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">              if (newObject) {</span>
<span class="fc" id="L1067">                linkObjects(metaObject, resultMapping, ancestorObject); // issue #385</span>
              }
<span class="fc" id="L1069">              continue;</span>
            }
          }
<span class="fc" id="L1072">          final CacheKey rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);</span>
<span class="fc" id="L1073">          final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);</span>
<span class="fc" id="L1074">          Object rowValue = nestedResultObjects.get(combinedKey);</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">          boolean knownValue = rowValue != null;</span>
<span class="fc" id="L1076">          instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject); // mandatory</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">          if (anyNotNullColumnHasValue(resultMapping, columnPrefix, rsw)) {</span>
<span class="fc" id="L1078">            rowValue = getRowValue(rsw, nestedResultMap, combinedKey, columnPrefix, rowValue);</span>
<span class="fc bfc" id="L1079" title="All 4 branches covered.">            if (rowValue != null &amp;&amp; !knownValue) {</span>
<span class="fc" id="L1080">              linkObjects(metaObject, resultMapping, rowValue);</span>
<span class="fc" id="L1081">              foundValues = true;</span>
            }
          }
<span class="nc" id="L1084">        } catch (SQLException e) {</span>
<span class="nc" id="L1085">          throw new ExecutorException(</span>
<span class="nc" id="L1086">              &quot;Error getting nested result map values for '&quot; + resultMapping.getProperty() + &quot;'.  Cause: &quot; + e, e);</span>
<span class="fc" id="L1087">        }</span>
      }
<span class="fc" id="L1089">    }</span>
<span class="fc" id="L1090">    return foundValues;</span>
  }

  private String getColumnPrefix(String parentPrefix, ResultMapping resultMapping) {
<span class="fc" id="L1094">    final StringBuilder columnPrefixBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">    if (parentPrefix != null) {</span>
<span class="fc" id="L1096">      columnPrefixBuilder.append(parentPrefix);</span>
    }
<span class="fc bfc" id="L1098" title="All 2 branches covered.">    if (resultMapping.getColumnPrefix() != null) {</span>
<span class="fc" id="L1099">      columnPrefixBuilder.append(resultMapping.getColumnPrefix());</span>
    }
<span class="fc bfc" id="L1101" title="All 2 branches covered.">    return columnPrefixBuilder.length() == 0 ? null : columnPrefixBuilder.toString().toUpperCase(Locale.ENGLISH);</span>
  }

  private boolean anyNotNullColumnHasValue(ResultMapping resultMapping, String columnPrefix, ResultSetWrapper rsw)
      throws SQLException {
<span class="fc" id="L1106">    Set&lt;String&gt; notNullColumns = resultMapping.getNotNullColumns();</span>
<span class="fc bfc" id="L1107" title="All 4 branches covered.">    if (notNullColumns != null &amp;&amp; !notNullColumns.isEmpty()) {</span>
<span class="fc" id="L1108">      ResultSet rs = rsw.getResultSet();</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">      for (String column : notNullColumns) {</span>
<span class="fc" id="L1110">        rs.getObject(prependPrefix(column, columnPrefix));</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (!rs.wasNull()) {</span>
<span class="fc" id="L1112">          return true;</span>
        }
<span class="fc" id="L1114">      }</span>
<span class="fc" id="L1115">      return false;</span>
    }
<span class="fc bfc" id="L1117" title="All 2 branches covered.">    if (columnPrefix != null) {</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">      for (String columnName : rsw.getColumnNames()) {</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix.toUpperCase(Locale.ENGLISH))) {</span>
<span class="fc" id="L1120">          return true;</span>
        }
<span class="fc" id="L1122">      }</span>
<span class="fc" id="L1123">      return false;</span>
    }
<span class="fc" id="L1125">    return true;</span>
  }

  private ResultMap getNestedResultMap(ResultSet rs, String nestedResultMapId, String columnPrefix)
      throws SQLException {
<span class="fc" id="L1130">    ResultMap nestedResultMap = configuration.getResultMap(nestedResultMapId);</span>
<span class="fc" id="L1131">    return resolveDiscriminatedResultMap(rs, nestedResultMap, columnPrefix);</span>
  }

  //
  // UNIQUE RESULT KEY
  //

  private CacheKey createRowKey(ResultMap resultMap, ResultSetWrapper rsw, String columnPrefix) throws SQLException {
<span class="fc" id="L1139">    final CacheKey cacheKey = new CacheKey();</span>
<span class="fc" id="L1140">    cacheKey.update(resultMap.getId());</span>
<span class="fc" id="L1141">    List&lt;ResultMapping&gt; resultMappings = getResultMappingsForRowKey(resultMap);</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">    if (resultMappings.isEmpty()) {</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">      if (Map.class.isAssignableFrom(resultMap.getType())) {</span>
<span class="nc" id="L1144">        createRowKeyForMap(rsw, cacheKey);</span>
      } else {
<span class="fc" id="L1146">        createRowKeyForUnmappedProperties(resultMap, rsw, cacheKey, columnPrefix);</span>
      }
    } else {
<span class="fc" id="L1149">      createRowKeyForMappedProperties(resultMap, rsw, cacheKey, resultMappings, columnPrefix);</span>
    }
<span class="fc bfc" id="L1151" title="All 2 branches covered.">    if (cacheKey.getUpdateCount() &lt; 2) {</span>
<span class="fc" id="L1152">      return CacheKey.NULL_CACHE_KEY;</span>
    }
<span class="fc" id="L1154">    return cacheKey;</span>
  }

  private CacheKey combineKeys(CacheKey rowKey, CacheKey parentRowKey) {
<span class="fc bfc" id="L1158" title="All 4 branches covered.">    if (rowKey.getUpdateCount() &gt; 1 &amp;&amp; parentRowKey.getUpdateCount() &gt; 1) {</span>
      CacheKey combinedKey;
      try {
<span class="fc" id="L1161">        combinedKey = rowKey.clone();</span>
<span class="nc" id="L1162">      } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L1163">        throw new ExecutorException(&quot;Error cloning cache key.  Cause: &quot; + e, e);</span>
<span class="fc" id="L1164">      }</span>
<span class="fc" id="L1165">      combinedKey.update(parentRowKey);</span>
<span class="fc" id="L1166">      return combinedKey;</span>
    }
<span class="fc" id="L1168">    return CacheKey.NULL_CACHE_KEY;</span>
  }

  private List&lt;ResultMapping&gt; getResultMappingsForRowKey(ResultMap resultMap) {
<span class="fc" id="L1172">    List&lt;ResultMapping&gt; resultMappings = resultMap.getIdResultMappings();</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">    if (resultMappings.isEmpty()) {</span>
<span class="fc" id="L1174">      resultMappings = resultMap.getPropertyResultMappings();</span>
    }
<span class="fc" id="L1176">    return resultMappings;</span>
  }

  private void createRowKeyForMappedProperties(ResultMap resultMap, ResultSetWrapper rsw, CacheKey cacheKey,
      List&lt;ResultMapping&gt; resultMappings, String columnPrefix) throws SQLException {
<span class="fc bfc" id="L1181" title="All 2 branches covered.">    for (ResultMapping resultMapping : resultMappings) {</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">      if (resultMapping.isSimple()) {</span>
<span class="fc" id="L1183">        final String column = prependPrefix(resultMapping.getColumn(), columnPrefix);</span>
<span class="fc" id="L1184">        final TypeHandler&lt;?&gt; th = resultMapping.getTypeHandler();</span>
<span class="fc" id="L1185">        Set&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span>
        // Issue #114
<span class="pc bpc" id="L1187" title="1 of 4 branches missed.">        if (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) {</span>
<span class="fc" id="L1188">          final Object value = th.getResult(rsw.getResultSet(), column);</span>
<span class="fc bfc" id="L1189" title="All 4 branches covered.">          if (value != null || configuration.isReturnInstanceForEmptyRow()) {</span>
<span class="fc" id="L1190">            cacheKey.update(column);</span>
<span class="fc" id="L1191">            cacheKey.update(value);</span>
          }
        }
      }
<span class="fc" id="L1195">    }</span>
<span class="fc" id="L1196">  }</span>

  private void createRowKeyForUnmappedProperties(ResultMap resultMap, ResultSetWrapper rsw, CacheKey cacheKey,
      String columnPrefix) throws SQLException {
<span class="fc" id="L1200">    final MetaClass metaType = MetaClass.forClass(resultMap.getType(), reflectorFactory);</span>
<span class="fc" id="L1201">    List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">    for (String column : unmappedColumnNames) {</span>
<span class="fc" id="L1203">      String property = column;</span>
<span class="pc bpc" id="L1204" title="1 of 4 branches missed.">      if (columnPrefix != null &amp;&amp; !columnPrefix.isEmpty()) {</span>
        // When columnPrefix is specified, ignore columns without the prefix.
<span class="fc bfc" id="L1206" title="All 2 branches covered.">        if (!column.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {</span>
<span class="fc" id="L1207">          continue;</span>
        }
<span class="fc" id="L1209">        property = column.substring(columnPrefix.length());</span>
      }
<span class="fc bfc" id="L1211" title="All 2 branches covered.">      if (metaType.findProperty(property, configuration.isMapUnderscoreToCamelCase()) != null) {</span>
<span class="fc" id="L1212">        String value = rsw.getResultSet().getString(column);</span>
<span class="fc bfc" id="L1213" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L1214">          cacheKey.update(column);</span>
<span class="fc" id="L1215">          cacheKey.update(value);</span>
        }
      }
<span class="fc" id="L1218">    }</span>
<span class="fc" id="L1219">  }</span>

  private void createRowKeyForMap(ResultSetWrapper rsw, CacheKey cacheKey) throws SQLException {
<span class="nc" id="L1222">    List&lt;String&gt; columnNames = rsw.getColumnNames();</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">    for (String columnName : columnNames) {</span>
<span class="nc" id="L1224">      final String value = rsw.getResultSet().getString(columnName);</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L1226">        cacheKey.update(columnName);</span>
<span class="nc" id="L1227">        cacheKey.update(value);</span>
      }
<span class="nc" id="L1229">    }</span>
<span class="nc" id="L1230">  }</span>

  private void linkObjects(MetaObject metaObject, ResultMapping resultMapping, Object rowValue) {
<span class="fc" id="L1233">    final Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">    if (collectionProperty != null) {</span>
<span class="fc" id="L1235">      final MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);</span>
<span class="fc" id="L1236">      targetMetaObject.add(rowValue);</span>
<span class="fc" id="L1237">    } else {</span>
<span class="fc" id="L1238">      metaObject.setValue(resultMapping.getProperty(), rowValue);</span>
    }
<span class="fc" id="L1240">  }</span>

  private Object instantiateCollectionPropertyIfAppropriate(ResultMapping resultMapping, MetaObject metaObject) {
<span class="fc" id="L1243">    final String propertyName = resultMapping.getProperty();</span>
<span class="fc" id="L1244">    Object propertyValue = metaObject.getValue(propertyName);</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">    if (propertyValue == null) {</span>
<span class="fc" id="L1246">      Class&lt;?&gt; type = resultMapping.getJavaType();</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">      if (type == null) {</span>
<span class="fc" id="L1248">        type = metaObject.getSetterType(propertyName);</span>
      }
      try {
<span class="fc bfc" id="L1251" title="All 2 branches covered.">        if (objectFactory.isCollection(type)) {</span>
<span class="fc" id="L1252">          propertyValue = objectFactory.create(type);</span>
<span class="fc" id="L1253">          metaObject.setValue(propertyName, propertyValue);</span>
<span class="fc" id="L1254">          return propertyValue;</span>
        }
<span class="nc" id="L1256">      } catch (Exception e) {</span>
<span class="nc" id="L1257">        throw new ExecutorException(</span>
<span class="nc" id="L1258">            &quot;Error instantiating collection property for result '&quot; + resultMapping.getProperty() + &quot;'.  Cause: &quot; + e,</span>
            e);
<span class="fc" id="L1260">      }</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">    } else if (objectFactory.isCollection(propertyValue.getClass())) {</span>
<span class="fc" id="L1262">      return propertyValue;</span>
    }
<span class="fc" id="L1264">    return null;</span>
  }

  private boolean hasTypeHandlerForResultObject(ResultSetWrapper rsw, Class&lt;?&gt; resultType) {
<span class="fc bfc" id="L1268" title="All 2 branches covered.">    if (rsw.getColumnNames().size() == 1) {</span>
<span class="fc" id="L1269">      return typeHandlerRegistry.hasTypeHandler(resultType, rsw.getJdbcType(rsw.getColumnNames().get(0)));</span>
    }
<span class="fc" id="L1271">    return typeHandlerRegistry.hasTypeHandler(resultType);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>